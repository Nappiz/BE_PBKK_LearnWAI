{"text": "LAPORAN PROYEK AKHIR PERANCANGAN dan ANALISIS \nALGORITMA (F) \nDosen: Bapak Rully Soelaiman, S.kom., M.kom. \nNama: Badruzzaman Nafiz \nNRP: 5025231196 \nKelompok: \n- Badruzzaman Nafiz – 5025231196 \n- Daffa Rinali – 5025231209 \n- Algof Kristian Zega - 5025231235 \n- Filbert Hainsly Martin - 5025231256 \n- Gregorius Setiadharma - 5025231268 \nPembagian Tugas: \nPermodelan GLB: \n- Gregorius Setiadharma \n- ⁠ Algof Kristian Zega \nPermodelan Geometri : \n- Daffa Rinali \n- Filbert Hainsly Martin \n- Gregorius Setiadharma \nPermodelan Lazy Segment Tree (termasuk perbandingan sama seg tree biasa): \n- Filbert Hainsly Martin \n- ⁠ Badruzzaman Nafiz \nPermodelan Sweep Line: \n- Daffa Rinali \n- ⁠ Algof Kristian Zega \nPembuatan Testcase : \n- Badruzzaman Nafiz \n- ⁠ Filbert Hainsly Martin \n- Daffa Rinali \n- ⁠ Algof Kristian Zega \nPermodelan Compressed Coordinate: \n- Badruzzaman Nafiz \n- ⁠Gregorius Setiadharma \nPengimplementasian Lazy Segment Tree: \n- Badruzzaman Nafiz \n- ⁠Filbert Hainsly Martin \n- ⁠Gregorius Setiadharma \nPengimplementasian Sweep Line: \n- Daffa Rinali \n- ⁠ Algof Kristian Zega \nSoal: SPOJ ZEBRA – The Zebra Crossing \nSubmission saya (Kode 1 Segment Tree + Sweep Line + Coordinate Compression) \n \nSubmission saya ( Kode 2 Pure Sweep Line ) \n \nSubmission Optimasi Kode 2 Pure Sweep Line) (0.02) \n \n\n \n \n \n\nDAFTAR ISI \n \nDAFTAR ISI ................................ ................................ ................................ ................................ ............... 4 \nAbstrak ................................ ................................ ................................ ................................ .................... 5 \nDasar Permasalahan ................................ ................................ ................................ ............................... 6 \n"}
{"text": "....................... ................................ ................................ ................................ .................... 5 \nDasar Permasalahan ................................ ................................ ................................ ............................... 6 \nDasar Teori ................................ ................................ ................................ ................................ .............. 6 \nSample Testcase dan Illustrasi Lintasannya ................................ ................................ ............................ 6 \nSeluruh Testcase ................................ ................................ ................................ ................................ ..... 8 \nPermodelan GLB ................................ ................................ ................................ ................................ ..... 8 \nPermodelan Geometri ................................ ................................ ................................ ............................ 8 \nAnalisis Masalah Mendasar: ................................ ................................ ................................ ................... 9 \nSource Code Segment Tree + Sweep Line + Coordinate Compression: ................................ ................ 11 \nPSEUDOCODE Segment Tree + Sweep Line + Coordinate Compression: ................................ ............. 15 \nPenjelasan Logika dan Algoritma Segment Tree + Sweep Line + Coordinate Compression: ............... 19 \nApproach Singkat ................................ ................................ ................................ .............................. 19 \nPermodelan Lazy Segment Tree ................................ ................................ ."}
{"text": "p Line + Coordinate Compression: ............... 19 \nApproach Singkat ................................ ................................ ................................ .............................. 19 \nPermodelan Lazy Segment Tree ................................ ................................ ................................ ....... 20 \nPermodelan Sweep Line ................................ ................................ ................................ .................... 22 \nPermodelan Compressed Coordinate ................................ ................................ ............................... 23 \nPengimplementasian Sweep Line ................................ ................................ ................................ ..... 27 \nPenjelasan Kode Tree + Sweep Line + Coordinate Compression: ................................ ........................ 28 \nMain() ................................ ................................ ................................ ................................ ................ 28 \nbestAnsZeroAdd() ................................ ................................ ................................ ............................. 30 \nPush() ................................ ................................ ................................ ................................ ................ 31 \nAdd() ................................ ................................ ................................ ................................ .................. 31 \nGetMax() ................................ ................................ ................................ ................................ ........... 32 \nBuild() ................................ ................................ ................................ ..................."}
{"text": "............ 31 \nGetMax() ................................ ................................ ................................ ................................ ........... 32 \nBuild() ................................ ................................ ................................ ................................ ................ 32 \nbestAns() ................................ ................................ ................................ ................................ ........... 33 \nSource Code Pure Sweep Line: ................................ ................................ ................................ ............. 34 \nPSEUDOCODE Pure Sweep Line: ................................ ................................ ................................ ........... 38 \nPenjelasan Logika dan Algoritma Pure Sweep Line: ................................ ................................ ............. 40 \nApproach Singkat ................................ ................................ ................................ .............................. 40 \nGrouping dan Forbidden Set ................................ ................................ ................................ ............. 40 \nDiskritasi Perpindahan (Displacement Candidates) ................................ ................................ .......... 41 \nPermodelan Sweep Line ................................ ................................ ................................ .................... 41 \nPengimplementasian Sweep Line ................................ ................................ ................................ ..... 42 \nSweep Line untuk Setiap Kandidat ................................ ................................ ................................ .... 43 \nPenjelasan Kode Pure Sweep Line: ."}
{"text": "sian Sweep Line ................................ ................................ ................................ ..... 42 \nSweep Line untuk Setiap Kandidat ................................ ................................ ................................ .... 43 \nPenjelasan Kode Pure Sweep Line: ................................ ................................ ................................ ....... 43 \nFungsi Pembantu ................................ ................................ ................................ .............................. 43 \nFungsi main() ................................ ................................ ................................ ................................ ..... 43 \nOptimasi (Revisi) ................................ ................................ ................................ ................................ ... 45 \nTujuan Awal Bagian Kode Tersebut ................................ ................................ ................................ .. 45 \nAlasan Penghapusan kode ................................ ................................ ................................ ................ 46 \nKesimpulan ................................ ................................ ................................ ................................ ............ 47 \nAlasan Memutuskan Untuk Merubah Kode ................................ ................................ ...................... 47 \nApa yang membuat kode kedua lebih efisien ................................ ................................ ................... 47 \nKenapa Menggunakan \"Displacement Candidates\"? Menyederhanakan Ruang Pencarian ............ 48 \nMekanisme Tabrakan Pada Kode Pertama dan Kode Kedua ................................ ............................ 48 \nPerbedaa"}
{"text": "..................... ................................ ................... 47 \nKenapa Menggunakan \"Displacement Candidates\"? Menyederhanakan Ruang Pencarian ............ 48 \nMekanisme Tabrakan Pada Kode Pertama dan Kode Kedua ................................ ............................ 48 \nPerbedaan Sweep Line Kode 1 dan Kode 2 ................................ ................................ ....................... 49 \nMengapa Awalnya Menggunakan Lazy Segment Tree Lalu Tidak ................................ .................... 49 \nDaftar Pustaka: ................................ ................................ ................................ ................................ ...... 50 \n \n \nAbstrak \nLaporan ini membahas perancangan dan analisis algoritma untuk menyelesaikan masalah \noptimasi SPOJ ZEBRA - The Zebra Crossing, yang bertujuan memaksimalkan jumlah potensi \ntabrakan dengan pejalan kaki lain yang bergerak dalam lintasan lurus. Dua pendekatan utama \ndieksplorasi. Pendekatan awal dirancang secara analitis untuk menyelesaikan mas alah \ngeometri 2D secara kontinu, mengimplementasikan struktur data Lazy Segment Tree yang \ndikombinasikan dengan algoritma Sweep Line dan Coordinate Compression. Namun, \npendekatan ini menunjukkan kompleksitas implementasi dan overhead komputasi yang \ntinggi, yang terbukti kurang efisien dalam praktiknya. \nSebagai respons, pendekatan kedua yang lebih efisien dikembangkan. Kunci dari pendekatan \nini adalah diskritisasi masalah: alih -alih menganalisis ruang solusi yang tak terbatas, \npencarian difokuskan pada sejumlah kecil 'kandidat' lintasan yang paling potens ial (misalnya, \nlurus, sudut maksimal, atau meniru lintasan lain). Transformasi ini menyederhanakan \nmasalah utama menjadi beberapa sub -masalah \"Maximum Interval Overlap\" yan"}
{"text": "enganalisis ruang solusi yang tak terbatas, \npencarian difokuskan pada sejumlah kecil 'kandidat' lintasan yang paling potens ial (misalnya, \nlurus, sudut maksimal, atau meniru lintasan lain). Transformasi ini menyederhanakan \nmasalah utama menjadi beberapa sub -masalah \"Maximum Interval Overlap\" yang dapat \ndiselesaikan secara efisien menggunakan algoritma pure sweep -line. Hasilnya menunjukkan \nbahwa pendekatan kedua, meskipun memiliki kompleksitas waktu teoretis yang serupa, \nsecara praktis jauh lebih unggul karena faktor konstanta yang lebih rendah. Proyek ini \nmenyimpulkan bahwa pemodelan masalah yang pragmatis dan pemilihan paradigm a \nalgoritma yang tepat (dalam hal ini, offline vs. online) seringkali lebih efektif daripada solusi \nanalitis yang kompleks untuk mencapai efisiensi. \nDasar Permasalahan \nInti dari problem ini adalah mendeteksi tabrakan antar objek yang bergerak dalam ruang 2D (jalan \nsebagai bidang) selama interval waktu tertentu. Setiap pejalan kaki, termasuk kita, bergerak dalam \nlintasan garis lurus dengan kecepatan konstan setelah lampu hijau menyala. Tabrakan terjadi ketika \nlintasan dua pejalan kaki berpotongan pada titik dan waktu yang sama \nProblem ini menggabungkan geometri gerak linier, pemodelan interval, dan algoritma struktur data \nuntuk memaksimalkan jumlah “tabrakan” di lintasan Pedesterian. Kita memilih kombinasi koordinat \ncompression, segment tree dengan lazy propagation, dan sweep‐li ne event (untuk kasus khusus) agar \nkompleksitas tetap O(n log n) dengan n ≤ 10.000 per grup. \nDasar Teori \nGerak Lurus Beraturan , Pergerakan setiap pejalan kaki dapat dimodelkan menggunakan persamaan \ngerak lurus beraturan, di mana posisi (x(t),y(t)) pada waktu t dapat dihitung dari posisi awal, \nkecepatan, dan arah Gerakan \nGeometri Segitiga & Trigon"}
{"text": "O(n log n) dengan n ≤ 10.000 per grup. \nDasar Teori \nGerak Lurus Beraturan , Pergerakan setiap pejalan kaki dapat dimodelkan menggunakan persamaan \ngerak lurus beraturan, di mana posisi (x(t),y(t)) pada waktu t dapat dihitung dari posisi awal, \nkecepatan, dan arah Gerakan \nGeometri Segitiga & Trigonometri, Konsep ini sangat penting untuk menghitung lintasan pejalan kaki \nberdasarkan sudut dan kecepatan, menentukan koordinat mereka di sisi seberang jalan, dan \nmenghitung jarak horizontal tambahan yang bisa ditempuh saat menyeberang miring, menggunakan \nhubungan sisi -sudut dalam segitiga \nLazy Segment Tree, Struktur data ini digunakan untuk mengelola dan meng kueri secara efisien \njumlah pejalan kaki yang aktif (lintasannya relevan) dalam rentang koordinat tertentu. Penerapan \n\"lazy\" memastikan pembaruan pada interval data yang besar dilakukan dengan cepat, mendukung \nalgoritma sweep line. \nSweep Line, Paradigma algoritma ini mengatur pemrosesan \"peristiwa\" (events) penting (misalnya, \npejalan kaki memulai atau mengakhiri lintasan di titik kritis) di sepanjang sebuah sumbu (X atau Y \nyang dikompresi). Dengan memproses events secara berurutan, m asalah perpotongan 2D dapat \ndiselesaikan secara efisien. \nCompressed Coordinate, Teknik ini mereduksi rentang nilai koordinat asli yang besar ke rentang \nindeks integer yang lebih kecil, hanya mempertahankan urutan relatif dari titik -titik kritis. Ini krusial \nagar struktur data seperti segment tree dapat digunakan dengan ukuran memori dan waktu komputasi \nyang wajar. \nTwo Pointers, Meskipun mungkin bukan inti algoritma utama, konsep ini muncul dalam kode solusi, \nkhususnya pada proses Compressed Coordinate untuk mengidentifikasi dan mengelompokkan nilai -\nnilai floating point yang berdekatan sebagai satu titik kritis, sert a se"}
{"text": "i dan waktu komputasi \nyang wajar. \nTwo Pointers, Meskipun mungkin bukan inti algoritma utama, konsep ini muncul dalam kode solusi, \nkhususnya pada proses Compressed Coordinate untuk mengidentifikasi dan mengelompokkan nilai -\nnilai floating point yang berdekatan sebagai satu titik kritis, sert a secara konseptual dalam iterasi dan \npemrosesan events selama sweep line \nSample Testcase dan Illustrasi Lintasannya \nInput: \n1 \n5 20 2 \n-20 10 2700 (orang ke -1) \n20 10 -2700 (orang ke -2) \n-5 1 4000 (orang ke -3) \n-4 1 4000 (orang ke -4) \n5 1 -4000 (orang ke -5) \nOutput: \n2 \n \nDari ke -lima pejalan kaki ini kita lakukan grouping berdasarkan waktu tempuh mereka (ti) sehingga \nkita dapat memangkas pejalan kaki yang tidak memiliki potensi tabrakan dengan kita seperti pejalan \nkaki ke -satu dan ke -2. \nSehingga kita dapat memilih jalur yang tabrakannya maksimum seperti gambar dibawah ini: \n \n\nSeluruh Testcase \nhttps://drive.google.com/file/d/1FYOPtaabKuoYRoQ -3mw -1g8IC28wVxi5/view?usp=sharing \nPermodelan GLB \nGerak lurus beraturan adalah gerak benda dengan kecepatan konstan. Ciri -ciri gerak lurus beraturan: \n1. Berada di sebuah lintasan lurus. \n2. Kecepatan benda konstan (tetap). \n3. Percepatan sama dengan nol (a=0). \nHal tersebut sesuai dengan penjelasan soal bahwa setiap pejalan kaki menyeberang dalam satu \nlintasan garis lurus tanpa berubah arah dengan kecepatan konstan (tabrakan tidak mempengaruhi \nkecepatan). Sehingga setiap pejalan kaki akan menyeberang dengan mengi kuti aturan gerak lurus \nPermodelan Geometri \n \n- Representasi Geometris Pejalan Kaki \nSetiap pejalan kaki dapat direpresentasikan sebagai titik dalam koordinat kartesius. Titik ini \nmemiliki : \no Posisi awal: Diberikan oleh koordinat ( xi, 0), di mana ( xi, ) adalah posisi horizontal \npejalan kaki di trotoar."}
{"text": " gerak lurus \nPermodelan Geometri \n \n- Representasi Geometris Pejalan Kaki \nSetiap pejalan kaki dapat direpresentasikan sebagai titik dalam koordinat kartesius. Titik ini \nmemiliki : \no Posisi awal: Diberikan oleh koordinat ( xi, 0), di mana ( xi, ) adalah posisi horizontal \npejalan kaki di trotoar. \no Waktu menyebrang : Direpresentasikan (ti, 0), yang menunjukkan ber apa lama \npejalan kaki tersebut akan meyebrang jalan. \no Sudut Pergerakan : Direpresentasikan ( ai,) dalam satuan 1/60 derajat yang \nmenunjukkan arah gerakan pejalan kaki relatif terhadap garis normal ke sisi jalan. \n \n- Transformasi Geometris Pergerakan Pejalan Kaki \n\no Perhitungan Posisi Akhir : Posisi akhir pejalan kaki di sisi seberang ( y = w ) \ndihitung dengan trigonometri. Sudut (a) digunakan untuk menghitung posisi y akhir \ndengan rumus ( y = tan(a) * w + x ). Ini adalah hasil dari proyeksi garis lurus \npergeraka n pejalan kaki: \n▪ Komponen Horizontal pergerakan berbanding lurus dengan ( tan (a) , yang \nmerupakan rasio perubahan x terhadap perubahan y. \n▪ Karena perubahan y adalah w ( lebar jalannya ), maka perubahan x adalah \n(tan(a) *w), sehingga posisi akhir x adalah ( x + tan(a) *w ). Kita \nrepresentasikan titik akhir tersebut dengan (y). \no Kecepatan : Kita mengelompokkan para pejalan kaki dalam ( groups[ti]), \nmeggunakan waktu (ti) yang menentukan kecepatan mereka (karena mereka \nmenyebrang dalam waktu (ti) \n- Geometri Interaksi Berdasarkan Waktu dan Kecepatan \no Mengelompokkan berdasarkan waktu menyeberang: Pejalan kaki dikelompokkan \nberdasarkan waktu pergerakan mereka (ti). Karena ini untuk merepresentasikan \npejalan kaki yang menyebrang dengan kecepatan yang sama ( karena vy = w / ti). \no Jarak Interaksi : Untuk setiap kelompok dengan waktu (ti), kita hitung jarak yang \ndapat ditempuh pad"}
{"text": "nyeberang: Pejalan kaki dikelompokkan \nberdasarkan waktu pergerakan mereka (ti). Karena ini untuk merepresentasikan \npejalan kaki yang menyebrang dengan kecepatan yang sama ( karena vy = w / ti). \no Jarak Interaksi : Untuk setiap kelompok dengan waktu (ti), kita hitung jarak yang \ndapat ditempuh pada sumbu horizontal berdasarkan kecepatan maksimum kita (v) dan \nwaktu (ti), yaitu ( distance = ti *v). Ini menunjukkan jarak maksimum yang dapat kita \ntempuh secara horizontal selama waktu tersebut : \n▪ Jika ( distance < w ), kita tidak dapat menyebrang cukup jauh untuk \nberinteraksi, jadi dilewati saja. \n▪ Jika (dist = w ), kita hanya dapat bergerak lurus saja, sehinnga membuat \nkasus khusus yang harus ditangani sendiri. \n▪ Jika ( dist > w ), kita dapat bergerak menyamping juga, dan jarak tambahan \nhorizontal yang dapat kita tempuh dihitung dengan ( add = √distance2 – w2), \nini karena pergerakan kita membentuk segitiga siku -siku dengan sisi vertikal \n(w) dan garis miring (distance). \n- Tabrakan sebagai Tumpang Tindih Posisi Horizontal \no Rentang Interaksi: Untuk setiap pejalan kaki pada posis awal (x), kita harus \nmenghitung rentang horizontal di mana kita dapat berinteraksi dengannya, yaitu dari \n(x-add) sampai (x+add). Ini merepresentasikan bahwa dengan kecepatan maksimum \nkita, kita dapat mencapai posisi horizontal tersebut saat mencapai sisi Seberang. \no Definisi Tabrakan : Tabrakan terjadi jika kita dan pejalan kaki mencapai posisi x yang \nsaman di sisi seberang ( y=w ) pada waktu yang sama. Secara geometris, ini berarti \ntrajektori garis lurus kita berpotongan dengan trajektori pejalan kaki di titik akhir \nperjalanan kita. \nAnalisis Masalah Mendasar: \n- Grouping berdasarkan Waktu: Kita hanya bisa bertabrakan dengan pejalan kaki yang memiliki \nwaktu menyeberang (ti) ya"}
{"text": " waktu yang sama. Secara geometris, ini berarti \ntrajektori garis lurus kita berpotongan dengan trajektori pejalan kaki di titik akhir \nperjalanan kita. \nAnalisis Masalah Mendasar: \n- Grouping berdasarkan Waktu: Kita hanya bisa bertabrakan dengan pejalan kaki yang memiliki \nwaktu menyeberang (ti) yang sama dengan waktu menyeberang kita. Jika waktu kita berbeda, \nkita tidak akan pernah berada di ketinggian (koordinat y) yang sama pada saat yang \nbersamaan. Jadi, langkah pertama yang logis adalah mengelompokkan semua pejalan kaki \nberdasarkan ti mereka. \n- Kondisi Tabrakan: Misalkan kita dan pejalan kaki i menyeberang dalam waktu T. \no Pejalan kaki i mulai dari (x_i, 0) dan berakhir di (q_i, w). \no Kita mulai dari (x_s, 0) dan berakhir di (q_s, w). \no Tabrakan terjadi jika lintasan kita dan lintasan pejalan kaki i berpotongan. Lintasan \nkita adalah garis lurus dari (x_s, 0) ke (q_s, w), dan lintasan mereka dari (x_i, 0) ke \n(q_i, w). \n- Fleksibilitas Kita: Kita memiliki dua pilihan utama: posisi awal x_s dan posisi akhir q_s. \nNamun, pilihan ini dibatasi oleh kecepatan maksimum v. Jarak yang kita tempuh adalah \nsqrt(w^2 + (q_s - x_s)^2). Waktu yang dibutuhkan adalah T. Maka, harus berlaku: \no \no Ini Menyiratkan: \no \no Kita sebut add = sqrt((vT)2 – w2) sebagai \"perpindahan horizontal maksimum\" kita \n- Transformasi Masalah: Inti masalahnya adalah memilih x_s dan q_s (dengan batasan |q_s - \nx_s| <= add) untuk memaksimalkan jumlah pejalan kaki i yang lintasannya berpotongan \ndengan lintasan kita. \nKondisi persimpangan lintasan dapat diturunkan menjadi: posisi awal kita, x_s, harus berada dalam \ninterval tertentu yang bergantung pada x_i, q_i, dan q_s. Secara spesifik, x_s harus berada di dalam \ninterval yang dibentuk oleh x_i dan q_i - (q_s - x_s). Ka rena q_s - x_s bisa berv"}
{"text": " lintasan kita. \nKondisi persimpangan lintasan dapat diturunkan menjadi: posisi awal kita, x_s, harus berada dalam \ninterval tertentu yang bergantung pada x_i, q_i, dan q_s. Secara spesifik, x_s harus berada di dalam \ninterval yang dibentuk oleh x_i dan q_i - (q_s - x_s). Ka rena q_s - x_s bisa bervariasi, ini menjadi \nmasalah geometri 2D yang rumit. \n \n\nSource Code Segment Tree + Sweep Line + Coordinate Compression: \n \n \n\n \n\n \n\n \n \n \n \n \n \n \n \n \n \n \n \n\nPSEUDOCODE Segment Tree + Sweep Line + Coordinate Compression : \n \n \n \n\n \n \n\n \n\n \n \n \n \n \n \n \n \n \n \n\nPenjelasan Logika dan Algoritma Segment Tree + Sweep Line + Coordinate \nCompression: \nApproach Singkat \n- Grouping: Sama seperti analisis di atas, kode ini mengelompokkan pejalan kaki berdasarkan ti \nke dalam unordered_map. y dalam kode sebenarnya adalah koordinat x akhir (q_i). \n- Dua Kasus: Kode ini membagi masalah menjadi dua kasus berdasarkan nilai add: \no Kasus 1: add = 0 (Menyeberang Lurus). Ini terjadi jika v * T = w. Kita tidak punya \nfleksibilitas; kita harus menyeberang lurus (q_s = x_s). Tabrakan terjadi jika titik x_s \nkita berada di antara x_i dan q_i milik pejalan kaki lain. Ini adalah masalah klasik \n\"Maximum Interval Overlap\". Fungsi bestAnsZeroAdd menyelesaikannya dengan \nalgoritma sweep -line standar. Ia m embuat \"event\" untuk setiap awal (x_i) dan akhir \n(q_i) interval, mengurutkannya, lalu menyapu garis untuk menemukan tumpukan \ninterval maksimum. \no Kasus 2: add > 0 (Menyeberang Miring). Ini adalah bagian yang rumit. Fungsi \nbestAns menyelesaikannya. Daripada mencoba setiap kemungkinan q_s, ia \nmenggunakan sweep -line yang digabungkan dengan Segment Tree with Lazy \nPropagation. \n▪ Koordinat Kompresi: Pertama, semua koordinat -x yang relevan (posisi awal \nx_i, posisi akhir q_i, dan batas interval q_i +"}
{"text": "ang rumit. Fungsi \nbestAns menyelesaikannya. Daripada mencoba setiap kemungkinan q_s, ia \nmenggunakan sweep -line yang digabungkan dengan Segment Tree with Lazy \nPropagation. \n▪ Koordinat Kompresi: Pertama, semua koordinat -x yang relevan (posisi awal \nx_i, posisi akhir q_i, dan batas interval q_i +/ - add) dikompresi menjadi \nindeks integer kecil. Ini untuk membuat ukuran Segment Tree menjadi lebih \nterkelola. \n▪ Sweep -line dengan Segment Tree: Algoritma Sweep sebuah garis (secara \nkonseptual) di sepanjang sumbu x (posisi awal pejalan kaki, x_i). Segment \nTree digunakan untuk melacak \"keuntungan\" dari memilih posisi akhir q_s \ntertentu. Saat sweep -line melewati x_i seorang pejalan kaki, ia melakukan \npembaruan pada Segment Tree. Query pada tree menanyakan: \"Untuk \nrentang posisi awal x_s saat ini, berapakah jumlah maksimum tabrakan yang \nbisa kita capai dengan memilih q_s secara optimal dalam rentang [x_s - add, \nx_s + add ]?\". Segment Tree secara efisien menjawab pertanyaan ini. \nSecara sederhana, approach ini menyelesaikan masalah secara analitis tanpa perlu menebak -nebak \nnilai optimal untuk perpindahan kita. \nBerikut adalah illustrasi tabrakan maksimum yang didapat dengan mengimplementasikan Segment \nTree dan Sweep Line: \n \nCara kerja berdasarkan Gambar: \n1. Proyeksi Interval. \nSetiap objek (garis merah, hijau, abu -abu) diproyeksikan ke sumbu X, menghasilkan interval \n1D. \no Garis Merah → [x_start_merah, x_end_merah] \no Garis Hijau → [x_start_hijau, x_end_hijau] \no Garis Abu -abu → [x_start_abu, x_end_abu] \n2. Update pada Segment Tree. \nSegment Tree dibangun untuk merepresentasikan seluruh sumbu X (di gambar, \ndirepresentasikan oleh rentang [1, 4]). Awalnya, semua nilai di pohon ini adalah 0 \n(dindingnya bersih). \nKemudian, kita memproses setiap interval satu p"}
{"text": "aris Abu -abu → [x_start_abu, x_end_abu] \n2. Update pada Segment Tree. \nSegment Tree dibangun untuk merepresentasikan seluruh sumbu X (di gambar, \ndirepresentasikan oleh rentang [1, 4]). Awalnya, semua nilai di pohon ini adalah 0 \n(dindingnya bersih). \nKemudian, kita memproses setiap interval satu per satu: \no Untuk Garis Merah: Lakukan operasi \"tambahkan 1\" pada rentang [x_start_merah, \nx_end_merah] di Segment Tree. Dengan Lazy Propagation, pohon secara efisien akan \nmenandai node -node yang relevan bahwa \"area ini sekarang memiliki +1 lapisan cat\". \no Untuk Garis Hijau: Lakukan hal yang sama. Tambahkan 1 pada rentang \n[x_start_hijau, x_end_hijau]. Jika ada area yang juga dicat oleh garis merah, maka \nnilai di node tersebut akan menjadi 2. \no Untuk Garis Abu -abu: Lakukan hal yang sama. \n3. Mencari Tabrakan Maksimum \nSetelah semua interval ditambahkan ke dalam pohon: \no Tugas kita adalah mencari nilai maksimum di seluruh Segment Tree. Nilai maksimum \nini merepresentasikan jumlah lapisan cat terbanyak. \no Titik berlabel “ 被选择的点 I” (Titik I yang dipilih) pada gambar adalah hasil dari \nquery ini. Itu adalah titik di sumbu X di mana jumlah tumpukan (tabrakan) mencapai \nnilai puncaknya. \nPermodelan Lazy Segment Tree \nPeran utama lazy segment tree pada Kode ini adalah sebagai struktur data untuk menyelesaikan sub -\nmasalah geometri 2D secara efisien dalam algoritma sweep -line, terutama untuk kasus di mana kita \nbisa menyeberang secara miring (add > 0). \n\nSecara spesifik, perannya dibagi menjadi dua fungsi krusial : \n- Range Query (Mencari Solusi Optimal) \no Saat algoritma melakukan sweep di sepanjang sumbu posisi awal (x_s), segment tree \ndigunakan untuk menjawab pertanyaan ini dengan cepat: \n▪ \"Dengan posisi awal saya saat ini, berapakah jumlah tabrakan maksimum \nyang bisa"}
{"text": " dibagi menjadi dua fungsi krusial : \n- Range Query (Mencari Solusi Optimal) \no Saat algoritma melakukan sweep di sepanjang sumbu posisi awal (x_s), segment tree \ndigunakan untuk menjawab pertanyaan ini dengan cepat: \n▪ \"Dengan posisi awal saya saat ini, berapakah jumlah tabrakan maksimum \nyang bisa saya dapatkan dengan memilih posisi akhir (q_s) secara optimal \ndari rentang yang diizinkan?” \no Fungsi GetMax pada kode melakukan query ini untuk mencari nilai maksimum \n(jumlah tabrakan terbanyak) pada sebuah rentang di dalam tree. \n- Lazy Range Update (Memperbarui Kondisi Masalah) \no Ketika garis sweep melewati posisi awal seorang pejalan kaki (x_i), aturan dan \nkemungkinan tabrakan berubah. Kita perlu memperbarui \"skor\" atau nilai untuk \nseluruh rentang kemungkinan posisi akhir secara bersamaan. \no Di sinilah peran \"lazy\" menjadi sangat penting. Ia memungkinkan pembaruan pada \nseluruh rentang ini dilakukan dalam waktu O(logN), yang sangat efisien. Tanpa lazy \npropagation, kita harus memperbarui setiap elemen satu per satu, yang akan memakan \nwaktu O(N) dan membuat solusi menjadi terlalu lambat. \nLazy Segment tree adalah struktur data yang memperluas konsep Segment Tree dengan \nmenambahkan fitur \"lazy propagation\" untuk meningkatkan efisiensi saat melakukan pembaruan \nrentang. Lazy Segment Tree menunda pembaruan nilai pada node tree hingga benar -benar diperlukan, \nsehingga mengurangi jumlah pembaruan yang sebenarnya. \n1. Query Range : Menemukan nilai agregat (seperti jumlah, minimum, maksimum) dalam \nrentang indeks tertentu [L, R]. \n2. Update Value: Mengubah nilai pada satu indeks tertentu \n3. Update Range : Mengubah nilai pada seluruh rentang indeks [L, R] (misalnya, menambahkan \nnilai x ke semua elemen dari indeks L hingga R, atau menetapkan semua elemen menjadi nilai "}
{"text": "inimum, maksimum) dalam \nrentang indeks tertentu [L, R]. \n2. Update Value: Mengubah nilai pada satu indeks tertentu \n3. Update Range : Mengubah nilai pada seluruh rentang indeks [L, R] (misalnya, menambahkan \nnilai x ke semua elemen dari indeks L hingga R, atau menetapkan semua elemen menjadi nilai \nv). Dalam segment tree standar,di kasus terburuk jika rentangnya lebar dan ki ta harus \nmengunjungi banyak node daun. \nKonsep Lazy segment tree : \n1. Lazy Value : Setiap node internal dalam lazy segment tree memiliki tempat tambahan untuk \nmenyimpan lazy value. Nilai ini merepresentasikan pembaruan yang harus diterapkan ke \nrentang yang dicakup oleh node ini dan semua keturunannya, tetapi belum diterapkan ke \nnode -node di bawahnya. \n2. Update range : \n• Jika node segment tree saat ini memiliki update tertunda (lazy value): \n1. Tambahkan dulu nilai update tertunda tersebut ke node saat ini. \n2. Sebarkan (propagate) nilai update ke child -childnya agar informasi tidak hilang. \n• Jika rentang [tl..tr] dari node saat ini berada sepenuhnya di dalam rentang update [l, r]: \n1. Perbarui nilai node saat ini sesuai operasi update. \n2. Tunda pembaruan ke child dengan menyimpan nilai update dalam lazy mereka, bukan \nlangsung mengubahnya. \n• Jika rentang node saat ini hanya beririsan (overlap sebagian) dengan rentang update: \n1. Rekursif: lakukan updateRange ke child kiri dan child kanan. \n2. Setelah itu, perbarui node saat ini berdasarkan hasil child kiri dan kanan (misalnya \nambil maksimum, jumlah, dst). \n3. Query Range (GetMax) : \n• Jika rentang node saat ini [tl, tr] di luar rentang kueri [L, R], maka mengembalikan nilai \nnetral (misalnya 0 untuk jumlah, −∞ untuk maksimum). \n• Jika rentang node saat ini [tl, tr] di dalam rentang kueri [L, R]: Nilai first ini harus sudah \nmencerminka"}
{"text": " jumlah, dst). \n3. Query Range (GetMax) : \n• Jika rentang node saat ini [tl, tr] di luar rentang kueri [L, R], maka mengembalikan nilai \nnetral (misalnya 0 untuk jumlah, −∞ untuk maksimum). \n• Jika rentang node saat ini [tl, tr] di dalam rentang kueri [L, R]: Nilai first ini harus sudah \nmencerminkan pembaruan yang tertunda yang dicatat dalam second di node ini. first \nlangsung diperbarui saat pembaruan lazy dicatat, jadi first sudah mencerminkan efek lazy \ndi level ini. \n• Jika rentang node saat ini [tl, tr] hanya sebagian tumpang tindih dengan rentang kueri [L, \nR], maka harus terlebih dahulu push lazy value apa pun yang ada di node saat ini ke anak -\nanaknya. \n• Panggil kueri secara rekursif pada node anak kiri dan kanan untuk bagian rentang kueri \nyang tumpang tindih dengan rentang masing -masing anak. \n• Gabungkan hasil dari panggilan rekursif, dengan cara jumlahkan hasil untuk kueri \njumlah. Kemudian, ambil maksimum untuk kueri maksimum. \nPermodelan Sweep Line \nSweep Line adalah sebuah teknik algoritmik yang digunakan untuk mengubah problem geometri 2D \nmenjadi serangkaian problem 1D yang diproses secara berurutan. Dalam problem ZEBRA, tujuannya \nadalah mencari jumlah maksimum perpotongan antara lintasan dengan lin tasan pejalan kaki lain. \nLintasan -lintasan ini adalah garis lurus dalam bidang 2D. Memeriksa setiap pasangan lintasan untuk \nperpotongan akan sangat tidak efisien, terutama dengan jumlah pejalan kaki yang besar. \nModel Sweep Line mengatasi ini dengan memperkenalkan sebuah garis imajiner (sweep line) yang \nbergerak melintasi bidang problem (bidang jalan). Garis ini biasanya bergerak paralel dengan salah \nsatu sumbu koordinat, misalnya sumbu Y dari kiri ke kanan (sepan jang sumbu X) atau sumbu X dari \nbawah ke atas (sepanjang sumbu Y). \"Status\" dari pro"}
{"text": "kenalkan sebuah garis imajiner (sweep line) yang \nbergerak melintasi bidang problem (bidang jalan). Garis ini biasanya bergerak paralel dengan salah \nsatu sumbu koordinat, misalnya sumbu Y dari kiri ke kanan (sepan jang sumbu X) atau sumbu X dari \nbawah ke atas (sepanjang sumbu Y). \"Status\" dari problem di sweep line (misalnya, jumlah lintasan \nyang aktif berpotongan dengan Sweep Line ) hanya perlu diperbarui ketika sweep line bertemu dengan \nsebuah \"event point\". Event point adalah koordinat pada sumbu sweep line di mana konfigurasi \ngeometris berubah secara signifikan – misalnya, sebuah lintasan dimulai, berakhir, atau berpotongan \ndengan lintasan lain pada sumbu sweep. \nDalam problem ZEBRA, permodelan sweep line digunakan untuk secara efisien menghitung tumpang \ntindih lintasan pejalan kaki dalam area yang relevan dengan lintasan potensial kita. Event points \ndidefinisikan oleh karakteristik pejalan kaki itu sendiri, seperti posisi awal mereka dan posisi mereka \ndi sisi seberang jalan, atau titik -titik yang relevan dengan perhitungan lintasan kita berdasarkan \nkecepatan dan waktu tempuh. Dengan memproses event points ini dalam urutan di sepanjang sumbu \nsweep, kita dapat menghitung jumlah lintasan yang aktif pada setiap titik atau interval di sepanjang \nsumbu tersebut. \nPermodelan Compressed Coordinate \nTeknik Compressed Coordinate adalah sebuah teknik optimasi yang digunakan dalam algoritma, \nterutama pada masalah geometri komputasional atau masalah yang melibatkan interval pada sumbu \ndengan rentang koordinat yang besar tetapi jumlah titik kritis (distinc t values) yang relatif kecil. \nIdenya adalah jika kita melihat pada urutan relatif dari titik -titik pada sebuah sumbu, dan operasi yang \nkita lakukan (seperti pada segment tree) hanya relevan pada interval yang "}
{"text": "val pada sumbu \ndengan rentang koordinat yang besar tetapi jumlah titik kritis (distinc t values) yang relatif kecil. \nIdenya adalah jika kita melihat pada urutan relatif dari titik -titik pada sebuah sumbu, dan operasi yang \nkita lakukan (seperti pada segment tree) hanya relevan pada interval yang dibatasi oleh titik -titik ini, \nmaka kita tidak perlu bekerja dengan nilai koo rdinat yang besar secara langsung. Kita bisa mengganti \nnilai koordinat asli yang besar dengan indeks integer yang lebih kecil, yang mencerminkan urutan \nrelatifnya. \nMisalnya, jika titik -titik kritis pada sumbu y adalah {1000, 5, 20000, 50}, setelah diurutkan menjadi \n{5, 50, 1000, 20000}. Kita bisa memetakan: \n• 5 -> 0 \n• 50 -> 1 \n• 1000 -> 2 \n• 20000 -> 3 \nSekarang, kita bisa bekerja dengan indeks 0, 1, 2, 3 alih -alih nilai asli yang besar. Ini sangat berguna \nketika menggunakan Segment Tree yang beroperasi pada array atau rentang indeks. Ukuran array atau \nsegment tree sekarang hanya bergantung pada jumlah ti tik kritis yang berbeda, bukan pada rentang \nnilai koordinat maksimum. \nPada fungsi bestAns (Lazy Segment Tree) dan bestAnsZeroAdd (Sweep Line), keduanya memiliki \nbagian serupa untuk Implementasi Compressed Coordinate: \n1. Pengumpulan titik kritis: \n• Vector allYToCompressed dibuat untuk menyimpan semua nilai koordinat y yang relevan \n• Koordinat y dari setiap pejalan kaki (point.second) ditambahkan. \n• Dalam bestAns, batas -batas interval y yang relevan untuk tabrakan potensial juga \nditambahkan. \n• Dalam bestAnsZeroAdd koordinat x pedesterian (point.first) juga ditambahkan, karena \ndalam kasus ini (penyeberangan lurus), koordinat x menjadi relevan untuk menentukan \ninterval pada garis sweep. \n• Nilai -nilai batas besar/kecil ( -60000, 60000 di bestAns -100000.0, 100000.0 di \nbestAnsZ"}
{"text": "ahkan. \n• Dalam bestAnsZeroAdd koordinat x pedesterian (point.first) juga ditambahkan, karena \ndalam kasus ini (penyeberangan lurus), koordinat x menjadi relevan untuk menentukan \ninterval pada garis sweep. \n• Nilai -nilai batas besar/kecil ( -60000, 60000 di bestAns -100000.0, 100000.0 di \nbestAnsZeroAdd) ditambahkan. ini untuk memastikan bahwa seluruh rentang yang \nrelevan tercakup, bahkan jika pejalan kaki tidak mencapai nilai ekstrem tersebut. \nPenambahan titik t engah antara koordinat x yang berurutan di bestAnsZeroAdd juga \nbertujuan untuk menangkap interval antara pejalan kaki. \n2. Pengurutan: \n• Vector allYToCompressed diurutkan. \n3. Penanganan nilai hampir sama (Floating Point) \n• Kode menangani potensi masalah presisi floating point dengan memeriksa nilai yang \n\"hampir sama\" menggunakan fabs(allYToCompressed[prev] - allYToCompressed[r]) < \nEPS. Nilai -nilai yang hampir sama ini diperlakukan sebagai satu titik yang sama dalam \nkompresi. Loop while(r < allYToCompressed.size() && fabs(allYToCompressed[prev] - \nallYToCompressed[r]) < EPS) mengelompokkan nilai -nilai yang berdekatan. \n4. Pemetaan ke Indeks \n• Dua map digunakan untuk pemetaan: \n• yCompressedTo: Map ini memetakan nilai koordinat asli (atau nilai -nilai yang hampir \nsama yang dikelompokkan) ke nilai koordinat yang unik dan direpresentasikan oleh \nelemen pertama dalam kelompok nilai yang hampir sama \n(yCompressedTo[allYToCompressed[i]] = allYToCompressed[l];). Ini dilakukan \nsetelah pengurutan dan pengelompokan. \n• toCompress: Map ini memetakan nilai -nilai koordinat unik (yang disimpan sebagai \nkey di yCompressedTo dan toCompress pada awalnya dengan nilai 1) ke indeks \ninteger berurutan dimulai dari 0 atau 1 (x.second = timer++;). \n5. Penggunaan indeks terkompresi \n• Setelah kompresi selesai, ukuran r"}
{"text": "kan. \n• toCompress: Map ini memetakan nilai -nilai koordinat unik (yang disimpan sebagai \nkey di yCompressedTo dan toCompress pada awalnya dengan nilai 1) ke indeks \ninteger berurutan dimulai dari 0 atau 1 (x.second = timer++;). \n5. Penggunaan indeks terkompresi \n• Setelah kompresi selesai, ukuran rentang indeks yang dikompresi (n = timer) digunakan \nuntuk membangun segment tree (build(1, 1, n)). \n• Selanjutnya, operasi Add dan GetMax pada segment tree menggunakan indeks \nterkompresi yang diperoleh dari toCompress[yCompressedTo[nilai_koordinat_asli]]. \nDapat kita lihat bahwa konsep Compressed Coordinate ini cara kerjanya mirip dengan std::map dan \nstd::unordered_map, namun yang membedakan adalah penanganan floating point pada koordinatnya. \nstd::map dan std::unordered_map menggunakan perbandingan ketat (operator< atau hash) untuk key. \nArtinya, 3.000000000000001 dan 3.000000000000002 akan dianggap sebagai dua kunci yang \nberbeda, meskipun secara praktis (dengan toleransi EPS) mereka seharusnya sama. \nDengan mengumpulkan ke std::vector, mengurutkan, dan kemudian melakukan deduplikasi manual \n(while(r < allYToCompressed.size() && fabs(allYToCompressed[prev] - allYToCompressed[r]) < \nEPS)), kita dapat memastikan bahwa semua nilai ld yang \"mirip\" (dalam bata s EPS) dipetakan ke ID \nterkompresi yang sama. std::map saja tidak bisa melakukan ini secara otomatis. \nInilah alasan penting mengapa kita lebih memilih untuk menggunakan compressed coordinate alih \nalih menggunakan std::map atau std::unordered_map. \nPengimplementasian Compressed Coordinate \nMisalkan dalam bestAns, setelah mengumpulkan koordinat y pejalan kaki dan batas -batas interval \ntabrakan berdasarkan add, kita mendapatkan nilai -nilai y: {15.3, 20.1, -5.8, 15.4, 30.0}. \nSetelah diurutkan (dan anggap 15.3 dan 15.4"}
{"text": "atau std::unordered_map. \nPengimplementasian Compressed Coordinate \nMisalkan dalam bestAns, setelah mengumpulkan koordinat y pejalan kaki dan batas -batas interval \ntabrakan berdasarkan add, kita mendapatkan nilai -nilai y: {15.3, 20.1, -5.8, 15.4, 30.0}. \nSetelah diurutkan (dan anggap 15.3 dan 15.4 dianggap berbeda karena EPS): { -5.8, 15.3, 15.4, 20.1, \n30.0}. \nDengan kompresi koordinat, ini bisa dipetakan menjadi indeks: \n• -5.8 -> 0 \n• 15.3 -> 1 \n• 15.4 -> 2 \n• 20.1 -> 3 \n• 30.0 -> 4 \nSegment tree kemudian dibangun untuk rentang indeks [0, 4]. Ketika kita perlu melakukan operasi \npada interval y asli, misalnya dari 15.3 hingga 20.1, kita mengonversi batas -batas ini ke indeks \nterkompresi (1 dan 3) dan melakukan operasi Add atau GetMax pada segment tree untuk rentang [1, \n3]. \nKompresi koordinat pada kode solusi adalah teknik penting untuk mereduksi rentang koordinat y (dan \nx dalam kasus khusus) ke rentang indeks yang lebih kecil. Ini memungkinkan penggunaan segment \ntree, yang membutuhkan rentang indeks yang terkontrol, untuk se cara efisien mengelola dan \nmelakukan query informasi tentang jumlah pejalan kaki yang aktif pada berbagai interval selama \nproses sweep line. Tanpa kompresi koordinat, segment tree akan terlalu besar dan solusinya akan \nmenjadi tidak efisien atau bahkan tida k memungkinkan karena keterbatasan memori. \nPengimplementasian Lazy Segment Tree \nLazy Segment Tree diimplementasikan dalam fungsi bestAns untuk secara efisien mengelola data \npada interval Y yang dikompresi. Struktur data ini direpresentasikan oleh array tree. \nFungsi build(int v, int tl, int tr): \nFungsi ini membangun segment tree secara rekursif untuk rentang indeks terkompresi [tl, tr], yang \ndicakup oleh node v. Node leaf (ketika tl == tr) diinisialisasi dengan nilai (0, 0), yang"}
{"text": " Y yang dikompresi. Struktur data ini direpresentasikan oleh array tree. \nFungsi build(int v, int tl, int tr): \nFungsi ini membangun segment tree secara rekursif untuk rentang indeks terkompresi [tl, tr], yang \ndicakup oleh node v. Node leaf (ketika tl == tr) diinisialisasi dengan nilai (0, 0), yang berarti jumlah \nlintasan awal adalah 0 dan tidak ada pembaruan tertun da. Node internal mendapatkan nilainya dari \nkombinasi nilai node anaknya. \nFungsi Push(int v): \nIni adalah inti dari lazy propagation. Jika sebuah node v memiliki nilai lazy (tree[v].second > 0), \nfungsi ini \"mendorong\" pembaruan lazy tersebut ke node -node anaknya (vBaru = v << 1 dan vBaru + \n1). Nilai lazy dari parent ditambahkan ke nilai .first dan . second anak -anaknya. Setelah pembaruan \ndipush, nilai lazy parent direset menjadi 0 (tree[v].second = 0). Ini memastikan bahwa pembaruan \nrentang yang hanya mempengaruhi sebagian besar node anak tidak segera memproses semua node di \nbawahnya, menunda pekerjaa n hingga node -node yang lebih rendah diakses. \nFungsi Add(int v, int tl, int tr, int l, int r, int x): \nFungsi ini digunakan untuk menambahkan nilai x ke semua elemen dalam rentang target [l, r] pada \nsumbu Y terkompresi \n• Jika rentang node saat ini [tl, tr] sepenuhnya berada di dalam rentang target [l, r], pembaruan \nx langsung diterapkan ke node v (tree[v].first += x; tree[v].second += x;) dan pembaruan ini \nakan disebarkan ke bawah nanti oleh Push. \n• Jika tidak, pembaruan x didorong ke bawah menggunakan Push(v), dan fungsi dipanggil \nsecara rekursif pada node -node anak untuk rentang yang tumpang tindih dengan [l, r]. \n• Setelah pemanggilan rekursif, nilai .first node v diperbarui sebagai nilai maksimum dari .first \nkedua anaknya (tree[v].first = max(tree[vBaru].first, tree[vBaru + 1].first);)."}
{"text": "kan Push(v), dan fungsi dipanggil \nsecara rekursif pada node -node anak untuk rentang yang tumpang tindih dengan [l, r]. \n• Setelah pemanggilan rekursif, nilai .first node v diperbarui sebagai nilai maksimum dari .first \nkedua anaknya (tree[v].first = max(tree[vBaru].first, tree[vBaru + 1].first);). \nFungsi GetMax(int v, int tl, int tr, int l, int r): \nFungsi ini digunakan untuk mencari nilai maksimum dalam rentang kueri [l, r] pada sumbu Y \nterkompresi \n• Jika rentang node saat ini [tl, tr] sepenuhnya berada di dalam rentang kueri [l, r], nilai .first \nnode v langsung dikembalikan. \n• Jika tidak, pembaruan lazy didorong ke bawah menggunakan Push(v), dan fungsi dipanggil \nsecara rekursif pada node -node anak untuk rentang yang tumpang tindih dengan [l, r]. Hasil \ndari pemanggilan rekursif digabungkan (menggunakan max) untuk mendapatkan nila i \nmaksimum di rentang kueri. \nPenggunaan dalam bestAns: \nDalam fungsi bestAns, setelah koordinat Y kritis dikompresi menjadi rentang indeks [1, n], segment \ntree dibangun (build(1, 1, n)). Kemudian, untuk setiap pejalan kaki, nilai 1 \"ditambahkan\" ke segment \ntree pada interval Y terkompresi tempat lintasan pejala n kaki tersebut aktif. Saat sweep line (diwakili \noleh loop for(int i = 0; i <= points.size(); i++) dan pembaruan/kueri segment tree), fungsi Add \ndigunakan untuk mencerminkan masuk dan keluarnya pejalan kaki dari \"jendela\" Y yang relevan, dan \nGetMax digunak an untuk menanyakan jumlah maksimum lintasan yang tumpang tindih dalam jendela \nY potensial lintasan. \nContoh Konseptual: \nMisalkan setelah kompresi koordinat, kita memiliki rentang indeks Y terkompresi dari 1 sampai 5 \n(n=5). Segment tree dibangun untuk rentang [1, 5]. \nAwal: Segment tree kosong, semua nilai diinisialisasi (misalnya 0). \nPejalan kaki 1: Lintasannya r"}
{"text": " jendela \nY potensial lintasan. \nContoh Konseptual: \nMisalkan setelah kompresi koordinat, kita memiliki rentang indeks Y terkompresi dari 1 sampai 5 \n(n=5). Segment tree dibangun untuk rentang [1, 5]. \nAwal: Segment tree kosong, semua nilai diinisialisasi (misalnya 0). \nPejalan kaki 1: Lintasannya relevan untuk rentang Y terkompresi [2, 4]. \n• Panggil Add(1, 1, 5, 2, 4, 1). Segment tree diperbarui. Node -node yang mencakup interval [2, \n4] akan memiliki nilai .first dan .second yang meningkat \nPejalan kaki 2: Lintasannya relevan untuk rentang Y terkompresi [3, 5]. \n• Panggil Add(1, 1, 5, 3, 5, 1). Node -node yang mencakup [3, 5] diperbarui. Jika ada tumpang \ntindih dengan pembaruan sebelumnya (misalnya, interval [3, 4]), nilai .first di node tersebut \nakan mencerminkan penjumlahan pembaruan (misalnya menjadi 2). \nSekarang, misalkan sweep line mencapai titik di mana lintasan kita potensial tumpang tindih dengan \npejalan kaki di rentang Y terkompresi [3, 4]. \n• Panggil GetMax(1, 1, 5, 3, 4). Segment tree akan memproses pembaruan lazy yang tertunda \njika ada, lalu mencari nilai maksimum di interval [3, 4]. Hasilnya akan menjadi jumlah \nmaksimum pejalan kaki yang lintasannya mencakup interval [3, 4] tersebut. \nKetika sweep line berlanjut dan pejalan kaki 1 tidak lagi relevan untuk interval tertentu. \n• Panggil Add(1, 1, 5, 2, 4, -1) untuk mengurangi hitungan pada rentang pejalan kaki 1. \nSegment tree secara efisien menjaga hitungan tumpang tindih lintasan pejalan kaki pada berbagai \ninterval Y terkompresi, memungkinkan algoritma sweep line untuk dengan cepat menanyakan jumlah \nmaksimum pada interval yang relevan dengan lintasan potensial. \n \nPengimplementasian Sweep Line \nImplementasi Sweep Line dalam solusi ini disesuaikan dengan dua kasus penyeberangan yang \nberbeda, meng"}
{"text": "ai \ninterval Y terkompresi, memungkinkan algoritma sweep line untuk dengan cepat menanyakan jumlah \nmaksimum pada interval yang relevan dengan lintasan potensial. \n \nPengimplementasian Sweep Line \nImplementasi Sweep Line dalam solusi ini disesuaikan dengan dua kasus penyeberangan yang \nberbeda, menggunakan struktur data yang sesuai untuk mengelola status sweep line. \n- Pada Fungsi bestAnsZeroAdd (Kasus Tegak Lurus): \no Sumbu Sweep: Implementasi sweep line pada kasus ini dilakukan di sepanjang \nsumbu X yang terkompresi. Ini karena kita menyeberang secara vertikal (X = xstart ), \ndan jumlah tabrakan tergantung pada berapa banyak lintasan pejalan kaki yang \nmelintasi garis vertikal di koordinat X tertentu. \no Event Points: Event points utama adalah koordinat X awal pejalan kaki \n(points[i].first). Titik -titik kritis tambahan seperti koordinat Y pejalan kaki di sisi \nseberang (points[i].second), titik tengah antara koordinat X pejalan kaki yang \nberurutan, dan nila i batas besar/kecil juga ditambahkan ke daftar event points untuk \nmemastikan bahwa semua interval relevan pada sumbu X terkompresi tercakup. \nSemua titik ini dikumpulkan dalam allYToCompressed (meskipun namanya 'Y', \ndigunakan untuk mengumpulkan titik X dan Y di sini sebelum kompresi) dan \nkemudian dikompresi. \no Struktur Data Event: Map m<ld, vector<int>> digunakan untuk mengorganisir event. \nKey dari map adalah nilai koordinat asli representatif dari sumbu X kritis (setelah \nkompresi dan penanganan floating point near -equality). Value -nya adalah vector dari \ninteger (kode 0 -5) yang merepresentasikan jenis event yang terjadi pada koordinat X \ntersebut. Kode -kode ini secara efektif menandai \"masuk\" atau \"keluar\" pejalan kaki \ndari area di sebelah kanan garis vertikal sweep line. \no Proses Sweep: Proses swee"}
{"text": "ear -equality). Value -nya adalah vector dari \ninteger (kode 0 -5) yang merepresentasikan jenis event yang terjadi pada koordinat X \ntersebut. Kode -kode ini secara efektif menandai \"masuk\" atau \"keluar\" pejalan kaki \ndari area di sebelah kanan garis vertikal sweep line. \no Proses Sweep: Proses sweep dilakukan dengan mengiterasi melalui map m (for (auto \nv : m)). Karena map secara otomatis mengurutkan berdasarkan key, ini setara dengan \nmenggerakkan garis vertikal sweep line dari X terkecil ke X terbesar. Sebuah counter \ncnt mel acak jumlah lintasan pejalan kaki yang saat ini melintasi garis vertikal pada \nkoordinat X saat ini. Ketika sweep line mencapai sebuah event point X, semua event \nyang terkait dengan X tersebut diproses. Event -event yang menandakan \"masuk\" \nmeningkatkan cnt, sementara event yang menandakan \"keluar\" mengurangi cnt. \no Tujuan: Pada setiap titik X kritis yang dilewati, cnt mencerminkan jumlah tabrakan \npotensial jika kita memilih x_{start} tepat di koordinat X tersebut. Algoritma mencari \nnilai maksimum dari cnt selama proses sweep (res = max(res, cnt)), yang \nmerepresentasikan jumlah tabrakan maksimum yang bisa dicapai. \n- Pada Fungsi bestAns (Kasus Miring) \no Sumbu Sweep: Implementasi sweep line di sini lebih fokus pada sumbu Y yang \nterkompresi. Karena lintasan miring kita menghubungkan suatu x_start di sisi kita \ndengan suatu y_end di sisi seberang (dengan jarak diagonal dist dan lebar w), \nmemilih x_start setara dengan memilih y_end. Dengan menganalisis tumpang tindih \nlintasan pejalan kaki di sepanjang sumbu Y di sisi seberang, kita dapat menentukan \njumlah tabrakan potensial. \no Event Points: Event points adalah koordinat Y pejalan kaki di sisi seberang \n(point.second) dan batas -batas interval Y di sisi seberang yang dapat dicapai oleh \nli"}
{"text": "lisis tumpang tindih \nlintasan pejalan kaki di sepanjang sumbu Y di sisi seberang, kita dapat menentukan \njumlah tabrakan potensial. \no Event Points: Event points adalah koordinat Y pejalan kaki di sisi seberang \n(point.second) dan batas -batas interval Y di sisi seberang yang dapat dicapai oleh \nlintasan kita (point.first - add, point.first + add). Titik -titik ini dikumpulkan dan \ndikompresi. \no Struktur Data Utama: Lazy Segment Tree digunakan sebagai struktur data untuk \nmengelola status \"jumlah lintasan aktif\" pada interval Y terkompresi. Segment tree \nmemungkinkan pembaruan efisien (dengan Add) dan kueri nilai maksimum (dengan \nGetMax) pada rentan g indeks Y terkompresi. \no Proses Sweep: Loop utama for (int i = 0; i <= points.size(); i++) dalam fungsi ini \nbertindak sebagai orkestrasi sweep line. Pada setiap langkah loop, algoritma secara \nimplisit mempertimbangkan \"jendela\" atau \"area\" potensial lintasan miring kita di sisi \nseberang jalan, yang ditentukan oleh posisi pejalan kaki ke -i dan nilai add. Batas Y \ndari jendela ini (left_y, right_y) dihitung dalam indeks terkompresi. \no Query dan Pembaruan: \n▪ GetMax(1, 1, n, left_y, right_y) digunakan untuk mengueri segment tree pada \nrentang Y terkompresi ini. Kueri ini mengembalikan jumlah maksimum \nlintasan pejalan kaki yang tumpang tindih dengan rentang Y yang relevan. \n▪ Add digunakan untuk memperbarui segment tree. Saat loop maju ke pejalan \nkaki berikutnya, pembaruan dilakukan pada segment tree untuk \nmencerminkan apakah pejalan kaki sebelumnya masih relevan atau tidak \nuntuk interval Y yang sedang dipertimbangkan. Ini sepe rti menambahkan \natau menghapus \"beban\" dari interval Y tertentu pada segment tree. \n \nPenjelasan Kode Tree + Sweep Line + Coordinate Compression: \nMain() \n- Pada fungsi Main pertama -tama k"}
{"text": "akah pejalan kaki sebelumnya masih relevan atau tidak \nuntuk interval Y yang sedang dipertimbangkan. Ini sepe rti menambahkan \natau menghapus \"beban\" dari interval Y tertentu pada segment tree. \n \nPenjelasan Kode Tree + Sweep Line + Coordinate Compression: \nMain() \n- Pada fungsi Main pertama -tama kita input t untuk memasukan jumlah testcase yang kita \ninginkan. \n- Didalam loop t --, kita lakukan input n, w, v yaitu jumlah pedesterians, lebar jalan, dan \nkecepatan maksimum kita. \n- Kita buat group m dengan unordered_map untuk melakukan grouping pedesterians \nberdasarkan ti atau waktu mereka menyebrang. \n- Selanjutnya kita loop sebanyak n \no Di loop ini, kita lakukan penginputan untuk pedesterians yaitu x, ti, a yang berarti \nposisi awal, lama waktu untuk menyebrang, dan sudutnya. \no Lalu kita tentukan y dengan cara: \n▪ Bagi a dengan 60 (derajat) \n▪ Bagi lagi dengan 180 dan dikali π (radian) \n▪ Kita tangenkan a tersebut (tan(a)) \n▪ Lalu kita kalikan tan(a) dengan w dan ditambah x (tan(a) * w + x) \no Lalu kita masukkan x dan y yang sudah kita dapat ke masing masing group \n- Inisialisasikan ans sebagai 0 \n- Kita lakukan perhitungan untuk setiap group yang sudah dibuat (loop group m) \no Di loop ini kita tentukan dulu jarak nya, dengan rumus GLB yaitu jarak = waktu * \nkecepatan (dist = cur.first * v) untuk mengetahui jarak terjauh yang secara fisik bisa \nkita capai dari titik awal kita dalam jumlah waktu yang sama yang dibutuhkan oleh \npejalan kaki (ti) untuk menyeberang jalan selebar w. \no Apabila dist < w maka continue karena kita tidak dapat mencapai sisi lain dalam \nwaktu yang sama, jadi tidak ada tabrakan. Contoh: \n▪ W = 20, cur.first (ti) = 1, dan v = 2 \n▪ Dist = 1 * 2 = 2, sementara w = 20 \n▪ Kita bahkan tidak bisa menempuh jarak selebar jalan (w) dalam waktu ti \nmesk"}
{"text": "ebar w. \no Apabila dist < w maka continue karena kita tidak dapat mencapai sisi lain dalam \nwaktu yang sama, jadi tidak ada tabrakan. Contoh: \n▪ W = 20, cur.first (ti) = 1, dan v = 2 \n▪ Dist = 1 * 2 = 2, sementara w = 20 \n▪ Kita bahkan tidak bisa menempuh jarak selebar jalan (w) dalam waktu ti \nmeskipun bergerak lurus dengan kecepatan maksimum. \no Apabila dist == w maka kita hanya bisa menempuh jarak tepat selebar jalan dalam \nwaktu ti yang berarti satu -satunya cara untuk mencapai sisi seberang dalam waktu ini \nadalah dengan bergerak tegak lurus melintasi jalan. Ini adalah kasus \"tegak lurus\" \nyang dit angani oleh bestAnsZeroAdd ( Sweep Line) \n▪ Kita lakukan loop lagi untuk setiap group dengan tujuan adalah untuk \nmenambahkan semua pejalan kaki dari kelompok waktu tempuh lain \n(curBaru.first != cur.first) ke vektor pejalan kaki dari kelompok waktu \ntempuh saat ini (cur.second). \n▪ Pejalan kaki dari kelompok lain ini ditambahkan dengan koordinat X asli \nmereka (p.first) tetapi dengan koordinat Y yang sangat besar (100000.0). \n▪ Ini adalah cara spesifik solusi ini mencoba memperhitungkan potensi \ntabrakan dengan pejalan kaki di luar kelompok waktu tempuh yang sedang \ndiproses, dalam kerangka algoritma sweep line bestAnsZeroAdd. \nMemberikan mereka Y yang sangat besar (100000.0) adalah sebuah trik atau \npermodelan spesifik dalam kode ini untuk mempengaruhi bagaimana mereka \ndiperlakukan dalam proses kompresi koordinat dan sweep line di \nbestAnsZeroAdd. Ini menandakan bahwa lintasan mereka berpotongan \ndengan garis vertical X = xstart tetapi \"jauh\" di atas sisi seberang (setelah \nmereka melewatinya) atau \"jauh\" di bawah sisi awal (sebelum mereka \nmencapainya), tetapi masih relevan untuk perpotongan dengan garis vertical \nX = xstart. \n▪ Lalu kita bandingkan ans = max(ans, be"}
{"text": "san mereka berpotongan \ndengan garis vertical X = xstart tetapi \"jauh\" di atas sisi seberang (setelah \nmereka melewatinya) atau \"jauh\" di bawah sisi awal (sebelum mereka \nmencapainya), tetapi masih relevan untuk perpotongan dengan garis vertical \nX = xstart. \n▪ Lalu kita bandingkan ans = max(ans, bestAnsZeroAdd(cur.second)) untuk \nmendapatkan nilai ans dari kasus dist == w \no Apabila dist > w maka kita bisa menempuh jarak lebih dari w dalam waktu ti yang \nmemungkinkan kita untuk menyeberang secara miring (diagonal). Jarak horizontal \ntambahan yang bisa kita tempuh di sisi Seberang (yaitu add) dihitung menggunakan \nteorema Pythagor as dari segitiga siku -siku yang dibentuk oleh lebar jalan (w), add, \ndan dist. Ini adalah kasus \"miring\" yang ditangani oleh bestAns \n▪ Sejauh ini yang sudah kita dapatkan adalah sisi Tegak (vertical) yaitu W atau \nlebar jalan dan sisi miring yaitu dist yang merupakan jarak total yang ktia \ntempuh secara diagonal. \n▪ Artinya dalam trigonometri yang belum kita ketahui adalah Sisi datar \n(horizontal), maka dari itu kita cari dengan horizontal = √miring2 – vertical2 \nmenjadi add = √1LL * dist * dist – 1LL * w * w \n▪ 1LL disini berperan untuk memastikan agar perhitungan perkaliannya \ndilakukan dengan presisi long long. \n▪ Lalu kita bandingkan ans = max(ans, bestAns(cur.second, add)) untuk \nmendapatkan nilai ans dari kasus dist > w \n- Terakhir, kita outputkan hasil akhir atau ans yang sudah didapat \nbestAnsZeroAdd() \nMenggunakan algoritma Sweep Line pada sumbu X yang dikompresi. Menghitung jumlah pejalan \nkaki yang melintasi garis vertikal X=x pada setiap posisi x di sepanjang jalan. \n- sort(points.begin(), points.end());: Mengurutkan vektor points yang berisi pasangan {posisi \nawal X, posisi akhir X di y=w} pejalan kaki, berdasarkan posisi awal X"}
{"text": "a sumbu X yang dikompresi. Menghitung jumlah pejalan \nkaki yang melintasi garis vertikal X=x pada setiap posisi x di sepanjang jalan. \n- sort(points.begin(), points.end());: Mengurutkan vektor points yang berisi pasangan {posisi \nawal X, posisi akhir X di y=w} pejalan kaki, berdasarkan posisi awal X mereka. \n- vector<ld> allYToCompressed;: Membuat vektor untuk mengumpulkan semua nilai koordinat \nyang relevan untuk kompresi koordinat pada sumbu X (dan Y dalam kasus ini). \n- for(int i = 0; i + 1 < points.size(); i++){ ... allYToCompressed.push_back(mid); }: Loop ini \nmenambahkan titik tengah (midpoint) antara posisi awal X dua pejalan kaki yang berurutan \nke allYToCompressed. Titik tengah ini penting untuk mendefinisikan interva l antara pejalan \nkaki di sumbu X. \n- allYToCompressed.push_back( -100000.0); allYToCompressed.push_back(100000.0);: \nMenambahkan nilai batas yang sangat kecil dan sangat besar ke allYToCompressed. Ini untuk \nmemastikan rentang kompresi mencakup semua kemungkinan koordinat yang relevan. \n- for(auto point : points){ ... allYToCompressed.push_back(x); ... \nallYToCompressed.push_back(y); }: Loop ini menambahkan posisi awal X (x) dan posisi \nakhir X di y=w (y) dari setiap pejalan kaki ke allYToCompressed. Ini adalah titik -titik kritis \ndi mana \"eve nt\" sweep line terjadi. \n- sort(allYToCompressed.begin(), allYToCompressed.end());: Mengurutkan semua koordinat \nyang terkumpul. \n- Bagian int l, r; l = r = 0; while(l < allYToCompressed.size()){ ... }: Ini adalah proses utama \nkompresi koordinat \no Mengiterasi melalui koordinat yang sudah diurutkan. \no Menggunakan two pointers (l dan r) untuk mengidentifikasi kelompok nilai yang \n\"hampir sama\" (dalam toleransi EPS) karena presisi floating point. \no Untuk setiap kelompok nilai yang hampir sama, yCompressed"}
{"text": "ah proses utama \nkompresi koordinat \no Mengiterasi melalui koordinat yang sudah diurutkan. \no Menggunakan two pointers (l dan r) untuk mengidentifikasi kelompok nilai yang \n\"hampir sama\" (dalam toleransi EPS) karena presisi floating point. \no Untuk setiap kelompok nilai yang hampir sama, yCompressedTo[nilai_asli] = \nnilai_representatif_kelompok memetakan nilai asli ke nilai representatif kelompok \ntersebut. \no toCompress[nilai_representatif_kelompok] = 1 (sementara) menandai bahwa nilai \nrepresentatif ini adalah titik unik yang akan diberi indeks terkompresi. \n- int timer = 0; for(auto &x : toCompress) x.second = timer++;: Mengiterasi melalui map \ntoCompress dan memberikan indeks integer berurutan (dimulai dari 0) untuk setiap nilai \nrepresentatif unik. n = timer adalah jumlah total indeks terkompresi. \n- vector<pair<int, int>> pointBaru; for(auto point : points){ ... pointBaru.push_back({xBaru, \nyBaru}); }: Mengonversi posisi awal X dan posisi akhir X di y=w setiap pejalan kaki ke \ndalam indeks terkompresi, menyimpannya dalam pointBaru. \n- int dontNeed = toCompress[yCompressedTo[100000.0]];: Mendapatkan indeks terkompresi \nuntuk nilai 100000.0 (yang digunakan untuk pejalan kaki dari grup lain). \n- map<ld, vector<int>> m;: Membuat map untuk menyimpan event sweep line. Key map \nadalah nilai koordinat asli representatif dari sumbu X (setelah kompresi). Value adalah vector \nyang berisi kode event. \n- for(auto p : pointBaru){ ... m[p.first].push_back(kode_event); ... }: Loop ini mengisi map m \ndengan event. Untuk setiap pejalan kaki (p dengan {X awal terkompresi, Y akhir \nterkompresi}), event ditambahkan ke map pada key yang sesuai dengan koordinat X yang \nrelevan, menggunakan kode 0, 1, 5, 2, 4, atau 3 untuk menandai jenis event (mulai/akhir \ninterval perpotongan garis ver"}
{"text": "mengisi map m \ndengan event. Untuk setiap pejalan kaki (p dengan {X awal terkompresi, Y akhir \nterkompresi}), event ditambahkan ke map pada key yang sesuai dengan koordinat X yang \nrelevan, menggunakan kode 0, 1, 5, 2, 4, atau 3 untuk menandai jenis event (mulai/akhir \ninterval perpotongan garis vertikal) berdasarkan hubungan antara X awal dan Y akhir pejalan \nkaki. \n- int cnt = 0; int res = 0;: Menginisialisasi counter cnt (jumlah lintasan yang melintasi garis \nvertikal sweep line saat ini) dan hasil maksimum res. \n- for(auto v : m){ ... }: Ini adalah loop utama sweep line. Mengiterasi melalui map m yang \nterurut berdasarkan key (koordinat X terkompresi). \no Mengambil semua event (vec) pada koordinat X saat ini. \no sort(vec.begin(), vec.end());: Mengurutkan event pada koordinat X yang sama \n(penting untuk pemrosesan event yang benar). \no Logika if(vec[0] < 4) { ... } else { ... }: Memproses event berdasarkan kodenya, \nmemperbarui cnt (bertambah atau berkurang) sesuai dengan aturan yang ditentukan \noleh kode event. Logika ini menghitung jumlah lintasan yang aktif melintasi garis \nvertikal pada posisi X saat ini. \no res = max(res, cnt);: Memperbarui res (jumlah maksimum tabrakan) dengan nilai cnt \nsaat ini. \n- toCompress.clear(); yCompressedTo.clear();: Membersihkan map kompresi untuk \npenggunaan berikutnya. \n- return res;: Mengembalikan jumlah maksimum tabrakan untuk kasus tegak lurus. \nPush() \nFungsi helper untuk Lazy Segment Tree. Menerapkan pembaruan \"lazy\" (tertunda) dari sebuah node \nparent ke node -node anaknya. \nJika node v memiliki nilai lazy (tree[v].second bukan nol), nilai lazy ini ditambahkan ke .first (nilai \nmaksimum) dan .second (nilai lazy) dari kedua node anaknya (vBaru dan vBaru + 1). Setelah \npembaruan disebarkan, nilai lazy node v direset menjadi \n- "}
{"text": " sebuah node \nparent ke node -node anaknya. \nJika node v memiliki nilai lazy (tree[v].second bukan nol), nilai lazy ini ditambahkan ke .first (nilai \nmaksimum) dan .second (nilai lazy) dari kedua node anaknya (vBaru dan vBaru + 1). Setelah \npembaruan disebarkan, nilai lazy node v direset menjadi \n- int vBaru = v << 1;: Menghitung indeks anak kiri (menggunakan bit shift, setara dengan v * \n2). \n- tree[vBaru].first += tree[v].second;: Menambahkan nilai lazy parent ke nilai maksimum anak \nkiri. \n- tree[vBaru].second += tree[v].second;: Menambahkan nilai lazy parent ke nilai lazy anak kiri. \n- tree[vBaru + 1].first += tree[v].second;: Menambahkan nilai lazy parent ke nilai maksimum \nanak kanan. \n- tree[vBaru + 1].second += tree[v].second;: Menambahkan nilai lazy parent ke nilai lazy anak \nkanan. \n- tree[v].second = 0;: Mereset nilai lazy parent menjadi nol setelah pembaruan disebarkan. \nAdd() \nMelakukan operasi penambahan (x) pada rentang indeks terkompresi [l, r] di dalam Lazy Segment \nTree. \nMelakukan traversal rekursif pada segment tree. Jika sebuah node mencakup rentang yang \nsepenuhnya berada di dalam rentang target [l, r], pembaruan diterapkan secara lazy. Jika tidak, \npembaruan lazy dari node saat ini disebarkan ke bawah (menggunakan Push), dan rekursi dilanjutkan \nke node -node anak yang tumpang tindih dengan rentang target. \n- if(l > r) return;: Base case: jika rentang target tidak valid, keluar. \n- if(tl == l && tr == r){ ... return; }: Jika rentang node saat ini [tl, tr] sama persis dengan \nrentang target [l, r], pembaruan x langsung diterapkan ke node ini (baik ke .first maupun \n.second untuk lazy propagation), lalu keluar. \n- Push(v);: Menyebarkan pembaruan lazy dari node saat ini ke anak -anaknya sebelum \nmelanjutkan traversal ke level yang lebih rendah. \n- in"}
{"text": "r] sama persis dengan \nrentang target [l, r], pembaruan x langsung diterapkan ke node ini (baik ke .first maupun \n.second untuk lazy propagation), lalu keluar. \n- Push(v);: Menyebarkan pembaruan lazy dari node saat ini ke anak -anaknya sebelum \nmelanjutkan traversal ke level yang lebih rendah. \n- int vBaru = v << 1; int mid = (tl + tr) >> 1;: Menghitung indeks anak kiri dan titik tengah \nrentang node saat ini. \n- Add(vBaru, tl, mid, l, min(r, mid), x);: Memanggil rekursif pada anak kiri untuk bagian \nrentang target yang tumpang tindih. \n- Add(vBaru + 1, mid + 1, tr, max(l, mid + 1), r, x);: Memanggil rekursif pada anak kanan \nuntuk bagian rentang target yang tumpang tindih. \n- tree[v].first = max(tree[vBaru].first, tree[vBaru + 1].first);: Setelah pemanggilan rekursif ke \nanak -anak, nilai .first node saat ini (nilai maksimum di rentangnya) diperbarui sebagai nilai \nmaksimum dari .first kedua anaknya. \nGetMax() \nMengkueri nilai maksimum pada rentang indeks terkompresi [l, r] di dalam Lazy Segment Tree. \nMelakukan traversal rekursif pada segment tree. Jika sebuah node mencakup rentang yang \nsepenuhnya berada di dalam rentang kueri [l, r], nilai .first dari node tersebut dikembalikan. Jika \ntidak, pembaruan lazy disebarkan ke bawah (menggunakan Push), dan rek ursi dilanjutkan ke node -\nnode anak yang tumpang tindih dengan rentang kueri. \n- if(l > r) return 0;: Kasus dasar rekursi: jika rentang kueri tidak valid, kembalikan 0 (atau nilai \nidentitas untuk operasi max). \n- if(tl == l && tr == r) return tree[v].first;: Jika rentang node saat ini [tl, tr] sama persis dengan \nrentang kueri [l, r], kembalikan nilai maksimum dari node ini. \n- Push(v);: Menyebarkan pembaruan lazy dari node saat ini ke anak -anaknya sebelum \nmelanjutkan traversal. \n- int vBaru = v << 1; int mid = ("}
{"text": "= l && tr == r) return tree[v].first;: Jika rentang node saat ini [tl, tr] sama persis dengan \nrentang kueri [l, r], kembalikan nilai maksimum dari node ini. \n- Push(v);: Menyebarkan pembaruan lazy dari node saat ini ke anak -anaknya sebelum \nmelanjutkan traversal. \n- int vBaru = v << 1; int mid = (tl + tr) >> 1;: Menghitung indeks anak kiri dan titik tengah \nrentang node saat ini. \n- return max(GetMax(vBaru, tl, mid, l, min(r, mid)), GetMax(vBaru + 1, mid + 1, tr, max(l, mid \n+ 1), r));: Memanggil rekursif pada anak kiri dan anak kanan untuk bagian rentang kueri yang \ntumpang tindih, lalu mengembalikan nilai maksimum dari kedua hasil rek ursi. \nBuild() \nMembangun dan menginisialisasi struktur Segment Tree pada array global tree. \nMembangun pohon secara rekursif. Node leaf (yang mencakup rentang indeks tunggal) diinisialisasi \ndengan nilai dasar (jumlah lintasan 0, nilai lazy 0). Node internal mendapatkan nilainya dari gabungan \nnilai node anaknya. \n- tree[v] = make_pair(0, 0);: Menginisialisasi node saat ini dengan nilai maksimum 0 dan nilai \nlazy 0. \n- if(tl == tr) return;: Kasus dasar rekursi: jika rentang node saat ini adalah titik tunggal (leaf), \nkeluar. \n- int vBaru = v << 1; int mid = (tl + tr) >> 1;: Menghitung indeks anak kiri dan titik tengah \nrentang node saat ini. \n- build(vBaru, tl, mid);: Memanggil rekursif untuk membangun sub -pohon kiri. \n- build(vBaru + 1, mid + 1, tr);: Memanggil rekursif untuk membangun sub -pohon kanan. \nbestAns() \nMenggunakan Sweep Line (implisit) pada sumbu Y yang dikompresi, didukung oleh Lazy Segment \nTree. \n- if(fabs(add) < EPS) add = 0; add = min(add, 1.0L * MAXN);: Menangani kasus add yang \nsangat kecil (dianggap 0) dan membatasi nilai add (mungkin untuk mencegah masalah presisi \natau rentang). \n- sort(points.begin(), points."}
{"text": "(implisit) pada sumbu Y yang dikompresi, didukung oleh Lazy Segment \nTree. \n- if(fabs(add) < EPS) add = 0; add = min(add, 1.0L * MAXN);: Menangani kasus add yang \nsangat kecil (dianggap 0) dan membatasi nilai add (mungkin untuk mencegah masalah presisi \natau rentang). \n- sort(points.begin(), points.end());: Mengurutkan pejalan kaki berdasarkan posisi awal X \nmereka. \n- vector<ld> allYToCompressed;: Membuat vektor untuk mengumpulkan semua koordinat Y \nkritis untuk kompresi. \n- Bagian for(int i = 0; i + 1 < points.size(); i++){ ... allYToCompressed.push_back(mid); }: \nMenambahkan titik tengah antara posisi awal X dua pejalan kaki yang berurutan (meskipun \nini Y kompresi, titik X ini relevan untuk permodelan). \n- allYToCompressed.push_back( -60000); allYToCompressed.push_back(60000);: \nMenambahkan nilai batas besar/kecil untuk rentang kompresi Y. \n- for(auto point : points){ ... }: Loop ini menambahkan koordinat Y akhir pejalan kaki (y), \nposisi awal X (x), dan batas -batas interval Y yang relevan dengan lintasan kita (x - add, x + \nadd) ke allYToCompressed. Ini adalah titik -titik kritis di sumbu Y. \n- sort(allYToCompressed.begin(), allYToCompressed.end());: Mengurutkan semua koordinat Y \nyang terkumpul. \n- Bagian kompresi koordinat (int l, r; l = r = 0; while(l < allYToCompressed.size()){ ... } dan \npengisian yCompressedTo, toCompress): Sama seperti di bestAnsZeroAdd, ini memetakan \nkoordinat Y kritis ke indeks terkompresi [0, n -1]. \n- build(1, 1, n);: Membangun Lazy Segment Tree di atas rentang indeks Y terkompresi. \n- for(auto point : points){ ... Add(1, 1, n, idx, n, 1); }: Menginisialisasi segment tree. Untuk \nsetiap pejalan kaki, tambahkan 1 pada rentang Y terkompresi dari indeks yang sesuai dengan \nY akhir pejalan kaki (idx) hingga indeks terakhir (n). Ini menanda"}
{"text": "Tree di atas rentang indeks Y terkompresi. \n- for(auto point : points){ ... Add(1, 1, n, idx, n, 1); }: Menginisialisasi segment tree. Untuk \nsetiap pejalan kaki, tambahkan 1 pada rentang Y terkompresi dari indeks yang sesuai dengan \nY akhir pejalan kaki (idx) hingga indeks terakhir (n). Ini menandai ba hwa pejalan kaki ini \n\"aktif\" dari Y akhirnya ke atas (dalam arti tertentu). \n- int ans = 0;: Menginisialisasi jawaban maksimum. \n- for(int i = 0; i <= points.size(); i++){ ... }: Ini adalah loop utama sweep line. Mengiterasi \nmelalui titik -titik yang terkait dengan pejalan kaki. Pada setiap langkah, ia menghitung batas \ninterval Y terkompresi (left_y, right_y) yang relevan dengan potens i titik akhir lintasan miring \nkita (berdasarkan posisi pejalan kaki ke -i dan add). \no ans = max(ans, GetMax(1, 1, n, left_y, right_y));: Melakukan kueri pada segment tree \nuntuk mendapatkan jumlah maksimum lintasan aktif di rentang Y terkompresi saat \nini, dan memperbarui jawaban maksimum. \no Bagian if(i < points.size()){ ... Add(...) ... }: Memperbarui segment tree saat sweep \nline ( konseptual) melewati pejalan kaki ke -i. Event di sini adalah \"perpindahan\" \nlintasan pejalan kaki di segment tree (misalnya, mengurangi hitungan di satu rentang \ndan menambah di rentang lain) saat sweep melewati titik yang terkait dengan pejalan \nkaki tersebu t. \n- toCompress.clear(); yCompressedTo.clear();: Membersihkan map kompresi. \n- return ans;: Mengembalikan jumlah maksimum tabrakan untuk kasus miring. \n \nSource Code Pure Sweep Line: \n \n\n \n\n \n\n \n\nPSEUDOCODE Pure Sweep Line: \n \n \n\n \n \n\nPenjelasan Logika dan Algoritma Pure Sweep Line: \nPendekatan pure sweep line ini menggunakan strategi yang lebih pragmatis dan berdasarkan intuisi \nmasalah untuk mencapai solusi yang sangat efisien. Ia menyadari bahw"}
{"text": "\n \nSource Code Pure Sweep Line: \n \n\n \n\n \n\n \n\nPSEUDOCODE Pure Sweep Line: \n \n \n\n \n \n\nPenjelasan Logika dan Algoritma Pure Sweep Line: \nPendekatan pure sweep line ini menggunakan strategi yang lebih pragmatis dan berdasarkan intuisi \nmasalah untuk mencapai solusi yang sangat efisien. Ia menyadari bahwa kita tidak perlu memeriksa \nsemua kemungkinan lintasan, tetapi hanya beberapa yang \"kritis \" dan paling potensial. \nApproach Singkat \nKode ini menggunakan pendekatan yang lebih pragmatis dan berdasarkan intuisi masalah. Saya \nmenyadari bahwa kita tidak perlu memeriksa semua kemungkinan perpindahan, tetapi hanya beberapa \nyang \"kritis\". \n- Grouping dan Forbidden Set: Sama seperti Kode 1, ia mengelompokkan pejalan kaki \nberdasarkan ti. Ia juga secara eksplisit menyimpan semua posisi awal pejalan kaki (xi) dalam \nsebuah unordered_set bernama forbiddenSet untuk menangani batasan \"tidak boleh mula i di \ntempat yang sama”. \n- Diskritasi Perpindahan (Displacement Candidates): Ini adalah ide kunci dari kode ini. Alih -\nalih mencoba menyelesaikan masalah untuk rentang kontinu perpindahan d_s = q_s - x_s, ia \nberhipotesis bahwa perpindahan optimal (chosen dalam kode) kemungkinan besar adalah \nsalah satu dari nilai -nilai berikut: \no 0: Menyeberang lurus. \no +/- dMxDisp: Menyeberang dengan sudut semaksimal mungkin ke kiri atau kanan \n(dMxDisp adalah add dari analisis kita). \no mdispx[i]: Perpindahan horizontal yang sama dengan pejalan kaki lain (mdispx[i] = \nq_i - x_i). Intuisi di sini adalah bahwa untuk memaksimalkan tabrakan, mungkin ada \nbaiknya meniru lintasan orang lain. \n- Sweep -Line untuk Setiap Kandidat: Untuk setiap perpindahan kandidat chosen yang telah \ndipilih. \no Masalahnya menjadi lebih sederhana: \"Dengan perpindahan chosen yang tetap, \ntemukan posisi awal x_s terbaik.\""}
{"text": "ah bahwa untuk memaksimalkan tabrakan, mungkin ada \nbaiknya meniru lintasan orang lain. \n- Sweep -Line untuk Setiap Kandidat: Untuk setiap perpindahan kandidat chosen yang telah \ndipilih. \no Masalahnya menjadi lebih sederhana: \"Dengan perpindahan chosen yang tetap, \ntemukan posisi awal x_s terbaik.\" \no Untuk setiap pejalan kaki i, kode menghitung interval posisi awal x_s yang \nmemungkinkan terjadinya tabrakan. Interval ini diberikan oleh [pstartx[i] + min(0, \nterm), pstartx[i] + max(0, term)] di mana term = mdispx[i] - chosen. \no Sekarang, ini kembali menjadi masalah Maximum Interval Overlap. Kode ini \nmenyelesaikannya dengan membuat events (+1 untuk awal interval, -1 untuk akhir), \nmengurutkannya, dan melakukan sapuan untuk mencari mxOverlap. \n- Penanganan Batasan: Setelah menemukan mxOverlap, kode ini melakukan pemeriksaan \ntambahan yang rumit untuk memastikan bahwa ada setidaknya satu posisi x_s yang valid \n(tidak berada di forbiddenSet) yang mencapai tumpukan maksimum tersebut. Jika semua titik \ndengan tumpukan maksimum dilarang, jawabannya mungkin mxOverlap – 1. \n \nGrouping dan Forbidden Set \nSama seperti approach sebelumnya, langkah pertama yang fundamental adalah mengelompokkan \nsemua pejalan kaki berdasarkan waktu tempuh mereka (ti), karena tabrakan hanya mungkin terjadi \ndalam kelompok waktu yang sama. \nSelain itu, pendekatan ini secara eksplisit menyimpan semua posisi awal pejalan kaki (xi) dalam \nsebuah struktur data unordered_set yang dinamai forbiddenSet. Tujuannya adalah untuk secara efisien \nmenangani batasan soal, yaitu kita tidak boleh memulai dari titik yang sudah ditempati oleh pejalan \nkaki lain . \nforbiddenSet adalah sebuah struktur data yang secara eksplisit dibuat untuk menegakkan salah satu \naturan penting dari soal: \"Anda dapat memutuskan di tit"}
{"text": "ya adalah untuk secara efisien \nmenangani batasan soal, yaitu kita tidak boleh memulai dari titik yang sudah ditempati oleh pejalan \nkaki lain . \nforbiddenSet adalah sebuah struktur data yang secara eksplisit dibuat untuk menegakkan salah satu \naturan penting dari soal: \"Anda dapat memutuskan di titik mana pun di sepanjang sisi jalan Anda akan \nmenunggu selain di tempat di mana pejalan kaki lain sudah berdiri\". \nTujuan utamanya adalah untuk menyimpan semua posisi awal xi dari setiap pejalan kaki lain, \nsehingga algoritma dapat dengan cepat memeriksa apakah sebuah kandidat posisi awal untuk kita \n(x_s) valid atau tidak. \nDiskritasi Perpindahan (Displacement Candidates) \nIni adalah ide kunci yang membedakan pendekatan ini dan menjadi sumber efisiensinya. Daripada \nmencoba menyelesaikan masalah untuk rentang kontinu perpindahan horizontal (d_s = q_s - x_s), \nkode ini berhipotesis bahwa perpindahan optimal (chosen dalam kode) kemungkinan besar adalah \nsalah satu dari beberapa nilai 'kritis' berikut: \n- 0: Menyeberang lurus secara vertical. \n- +/- dMxDisp: Menyeberang dengan sudut semaksimal mungkin ke kiri atau ke kanan, \nmemanfaatkan seluruh kecepatan maksimum kita. (dMxDisp ini setara dengan nilai add pada \nanalisis kode pertama). \n- mdispx[i]: Meniru perpindahan horizontal pejalan kaki lain (mdispx[i] = q_i - x_i) dalam \nkelompok waktu yang sama. Intuisi di baliknya adalah bahwa untuk memaksimalkan \ntabrakan, meniru lintasan orang lain adalah strategi yang sangat potensial. \nDengan membatasi pencarian hanya pada kandidat -kandidat ini, ruang solusi yang tak terbatas \ndireduksi menjadi beberapa kasus diskrit yang dapat diuji satu per satu. \nPermodelan Sweep Line \nSweep Line adalah sebuah teknik algoritmik yang digunakan untuk mengubah problem geometri 2D \nmenjadi serangka"}
{"text": "engan membatasi pencarian hanya pada kandidat -kandidat ini, ruang solusi yang tak terbatas \ndireduksi menjadi beberapa kasus diskrit yang dapat diuji satu per satu. \nPermodelan Sweep Line \nSweep Line adalah sebuah teknik algoritmik yang digunakan untuk mengubah problem geometri 2D \nmenjadi serangkaian problem 1D yang diproses secara berurutan. Dalam problem ZEBRA, tujuannya \nadalah mencari jumlah maksimum perpotongan antara lintasan kita dengan lintasan pejalan kaki lain. \nMemeriksa setiap pasangan lintasan untuk perpotongan akan sangat tidak efisien, terutama dengan \njumlah pejalan kaki yang besar. \nPendekatan ini mengatasi inefisiensi tersebut dengan cara yang unik. Pertama, masalah \ndisederhanakan dengan diskritisasi perpindahan , di mana kita hanya menguji beberapa kandidat \nlintasan yang paling potensial. Untuk setiap kandidat lintasan yang tetap , masalahnya berubah \nmenjadi: \"Di mana posisi awal x_s terbaik untuk memaksimalkan tabrakan?\". \nMasalah yang disederhanakan ini adalah masalah klasik \"Maximum Interval Overlap\". Di sinilah \nsweep line berperan: \n- Sweep Line: Kita membayangkan sebuah garis vertikal yang bergerak (menyapu) di \nsepanjang sumbu X dari kiri ke kanan. Sumbu X ini merepresentasikan semua kemungkinan \nposisi awal kita. \n- Event Points: \"Peristiwa\" terjadi pada titik -titik di mana status masalah berubah. Dalam kasus \nini, event points adalah titik awal dan akhir dari \"interval tabrakan\". Setiap pejalan kaki, \nuntuk lintasan kita yang sudah dipilih, akan menghasilkan satu interval di sumbu X di mana \ntabrakan mungkin terjadi. \n- Status: \"Status\" yang kita lacak adalah jumlah interval yang sedang aktif atau tumpang tindih \npada posisi sweep line saat ini. Jumlah ini setara dengan jumlah pejalan kaki yang bisa kita \ntabrak jika kita memulai dari p"}
{"text": "kan menghasilkan satu interval di sumbu X di mana \ntabrakan mungkin terjadi. \n- Status: \"Status\" yang kita lacak adalah jumlah interval yang sedang aktif atau tumpang tindih \npada posisi sweep line saat ini. Jumlah ini setara dengan jumlah pejalan kaki yang bisa kita \ntabrak jika kita memulai dari posisi tersebut. \nDengan memproses event points ini secara berurutan, kita dapat secara efisien menemukan posisi di \nsumbu X yang ditutupi oleh jumlah interval terbanyak, yang memberikan kita jumlah tabrakan \nmaksimum untuk kandidat lintasan tersebut. \nPengimplementasian Sweep Line \nImplementasi Sweep Line dalam solusi ini secara langsung menyelesaikan masalah \"Maximum \nInterval Overlap\" untuk setiap kandidat lintasan yang diuji. \nPada Fungsi Main (di dalam loop kandidat chosen) \n- Sumbu Sweep: Implementasi secara konseptual menyapu sepanjang sumbu X, yang \nmerepresentasikan posisi awal kita (x_s). \n- Event Points: \no Untuk setiap kandidat perpindahan chosen, dan untuk setiap pejalan kaki i dalam \nkelompok waktu yang sama, sebuah \"interval tabrakan\" [L, R] dihitung. \no Interval ini kemudian diubah menjadi dua event: \n▪ {L, +1}: Menandakan dimulainya sebuah interval tabrakan. \n▪ {R, -1}: Menandakan berakhirnya sebuah interval tabrakan. \no Semua event ini dikumpulkan dalam vector<pair<double, int>> events. \n- Struktur Data Event: \no Sebuah std::vector digunakan untuk menyimpan semua event. \no Jika koordinat sama, event +1 (awal interval) didahulukan sebelum event -1 (akhir \ninterval). Ini penting untuk menangani interval yang bertemu di satu titik dengan \nbenar. \n- Proses Sweep: \no Proses sweep dilakukan dengan sebuah loop for yang mengiterasi events yang sudah \nterurut. \no Sebuah counter currOverlap diinisialisasi dengan nilai 0. Counter ini melacak jumlah \ninterval yang aktif "}
{"text": " Ini penting untuk menangani interval yang bertemu di satu titik dengan \nbenar. \n- Proses Sweep: \no Proses sweep dilakukan dengan sebuah loop for yang mengiterasi events yang sudah \nterurut. \no Sebuah counter currOverlap diinisialisasi dengan nilai 0. Counter ini melacak jumlah \ninterval yang aktif pada posisi sweep line saat ini. \no Saat loop memproses setiap event, currOverlap diperbarui dengan menambahkan \nnilai event.second (+1 atau -1). \no Setelah setiap pembaruan, nilai mxOverlap (yang menyimpan hasil maksimum) \ndiperbarui dengan max(mxOverlap, currOverlap). \n- Tujuan: Setelah loop selesai, mxOverlap akan berisi jumlah tumpang tindih interval \nmaksimum, yang setara dengan jumlah tabrakan terbanyak untuk kandidat lintasan chosen \nyang sedang diuji. \n- Penanganan Batasan: \no Setelah mxOverlap ditemukan, sebuah loop tambahan memverifikasi apakah ada \nsetidaknya satu posisi awal yang valid (tidak berada di forbiddenSet) yang dapat \nmencapai mxOverlap tersebut. \no Jika semua titik dengan tumpukan maksimum ternyata dilarang, jawaban yang valid \nuntuk kandidat tersebut mungkin adalah mxOverlap – 1. \no Hasil akhir adalah nilai best yang merupakan nilai maksimum dari semua actual yang \nditemukan dari setiap kandidat chosen. \nSweep Line untuk Setiap Kandidat \nUntuk setiap kandidat perpindahan chosen yang telah dipilih, masalah yang tadinya rumit menjadi \njauh lebih sederhana. \n- Interval Tabrakan: Untuk setiap pejalan kaki i, kode menghitung sebuah interval posisi \nawal x_s di sisi kita yang akan menyebabkan terjadinya tabrakan jika kita menggunakan \nperpindahan chosen. \n- Maximum Interval Overlap: Masalah ini kini menjadi masalah klasik \"Maximum Interval \nOverlap\". Kode menyelesaikannya dengan algoritma sweep -line standar: \no Membuat \"event\" (+1) untuk setiap awal interva"}
{"text": "si kita yang akan menyebabkan terjadinya tabrakan jika kita menggunakan \nperpindahan chosen. \n- Maximum Interval Overlap: Masalah ini kini menjadi masalah klasik \"Maximum Interval \nOverlap\". Kode menyelesaikannya dengan algoritma sweep -line standar: \no Membuat \"event\" (+1) untuk setiap awal interval dan ( -1) untuk setiap akhir interval. \no Mengurutkan semua event berdasarkan koordinatnya. \no Sweep (melakukan iterasi) melalui event yang sudah terurut sambil menjaga sebuah \ncounter (currOverlap). Nilai maksimum dari counter ini (mxOverlap) adalah jumlah \ntabrakan terbanyak yang mungkin untuk kandidat perpindahan chosen yang sedang \ndiuji. \nPenjelasan Kode Pure Sweep Line: \nFungsi Pembantu \n- fastIO() \nFungsi ini adalah teknik optimasi untuk membaca input integer dengan sangat cepat, lebih \ncepat dari scanf atau cin. Ini penting dalam kompetisi agar tidak terkena Time Limit Exceeded \npada test case dengan input besar. Ia bekerja dengan membaca karakter sat u per satu. \n- isForbidden(double coords, const unordered_set<int> &forbiddenSet) \nFungsi ini memeriksa apakah sebuah koordinat coords (bertipe double) berada pada posisi \nyang \"terlarang\". Posisi terlarang adalah posisi awal dari pejalan kaki lain. \no Karena coords adalah double, ia mungkin tidak persis sama dengan integer (misal: \n5.0000000001). Fungsi ini dengan cerdas memeriksa apakah coords \"sangat dekat\" \n(dalam toleransi EPS) dengan nilai floor atau ceil -nya yang ada di dalam \nforbiddenSet. \no unordered_set digunakan agar pencarian (.count()) bisa dilakukan dalam waktu rata -\nrata O(1). \nFungsi main() \n- Inisialisasi & Pengelompokan Data \no Baca Input: Membaca t (jumlah test case), lalu dalam setiap test case membaca n \n(jumlah pejalan kaki), w (lebar, misal lebar jalan), dan v (kecepatan pengamat). \no Data Pej"}
{"text": " agar pencarian (.count()) bisa dilakukan dalam waktu rata -\nrata O(1). \nFungsi main() \n- Inisialisasi & Pengelompokan Data \no Baca Input: Membaca t (jumlah test case), lalu dalam setiap test case membaca n \n(jumlah pejalan kaki), w (lebar, misal lebar jalan), dan v (kecepatan pengamat). \no Data Pejalan Kaki: Membaca data setiap pejalan kaki: xi (posisi x awal), ti (waktu), \ndan ai (sudut). \no forbiddenSet: Semua posisi awal pejalan kaki (xi) dimasukkan ke dalam forbiddenSet \nuntuk digunakan oleh fungsi isForbidden nanti. \no Pengelompokan berdasarkan Waktu (unordered_map m): \n▪ Ini adalah langkah optimasi krusial. Logika masalahnya tampaknya \nindependen untuk setiap nilai waktu ti yang unik. \n▪ Kode ini membuat sebuah map m di mana key adalah ti dan value adalah \nvector berisi indeks dari semua pejalan kaki yang memiliki waktu ti tersebut. \n▪ Kondisi if(w <= v * ti[i] + EPS): Pejalan kaki hanya dipertimbangkan jika \njarak yang bisa ditempuh pengamat (v * ti) setidaknya sama dengan lebar w. \nJika tidak, pengamat tidak akan pernah bisa \"melihat\" pejalan kaki tersebut, \njadi datanya diabaikan. \n- Loop Utama per Grup Waktu (for(const auto &kv : m)) \no Hitung Geometri Pejalan Kaki \n▪ Untuk setiap pejalan kaki dalam grup, kode menghitung displacement \n(perpindahan horizontal). Ini didasarkan pada lebar w dan sudut ai. \n▪ angle = ai[originalIdx] * PI / (60.0 * 180.0): Ini adalah konversi sudut dari \nunit yang spesifik di soal ke radian. \n▪ displacement = w * tan(angle): Rumus trigonometri standar untuk mencari \nperpindahan horizontal. \no Identifikasi Kandidat Posisi Pengamat (dCand): \n▪ dMxDisp: Menghitung perpindahan horizontal maksimum yang bisa \ndilakukan oleh pengamat. Ini didapat dari rumus Pythagoras: (jarak_total)2 = \n(jarak_vertikal)2 + (jarak_horizontal)2 atau (v ⋅ t)"}
{"text": "ometri standar untuk mencari \nperpindahan horizontal. \no Identifikasi Kandidat Posisi Pengamat (dCand): \n▪ dMxDisp: Menghitung perpindahan horizontal maksimum yang bisa \ndilakukan oleh pengamat. Ini didapat dari rumus Pythagoras: (jarak_total)2 = \n(jarak_vertikal)2 + (jarak_horizontal)2 atau (v ⋅ t)2 = w2 + (displacement)2. \nMaka, dMxDisp adalah atau √ (v ⋅ t)2 - w2. \n▪ dCand (Candidate Displacements): Ini adalah daftar \"perpindahan pengamat\" \nyang menarik untuk diuji. Logikanya, solusi optimal kemungkinan besar \nterjadi ketika posisi pengamat memiliki hubungan geometris tertentu dengan \nposisi pejalan kaki. Jadi, yang diuji hanya: \n• Perpindahan maksimum pengamat ( -dMxDisp dan dMxDisp). \n• Perpindahan nol. \n• Semua perpindahan pejalan kaki (mdispx) yang berada dalam \njangkauan pengamat \n▪ sort dan unique digunakan untuk membersihkan daftar kandidat ini dari \nduplikat. \n- Inti Algoritma: Sweep Line per Kandidat (for(double chosen : dCand)) \no Ini adalah jantung dari keseluruhan logika. Untuk setiap kemungkinan perpindahan \npengamat (chosen) yang sudah kita saring, kita hitung berapa pejalan kaki maksimum \nyang bisa dikelompokkan. \no Membuat Event Intervals [L, R]: \n▪ Untuk setiap pejalan kaki, kita mendefinisikan sebuah interval [L, R]. \n▪ Interval ini merepresentasikan rentang posisi di sumbu X di mana pengamat \nbisa berdiri untuk \"mengelompokkan\" pejalan kaki tersebut, dengan asumsi \npengamat memiliki perpindahan chosen. \n▪ term = mdispx[i] - chosen adalah perpindahan relatif antara pejalan kaki dan \npengamat. \n▪ L = pstartx[i] + min(0.0, term) dan R = pstartx[i] + max(0.0, term) adalah \ncara cerdas untuk mendefinisikan rentang ini. \no Menjalankan Sweep Line: \n▪ Setiap interval [L, R] diubah menjadi dua \"event\": (L, +1) dan (R, -1). \n▪ sort(events, ...): Semua event "}
{"text": "tif antara pejalan kaki dan \npengamat. \n▪ L = pstartx[i] + min(0.0, term) dan R = pstartx[i] + max(0.0, term) adalah \ncara cerdas untuk mendefinisikan rentang ini. \no Menjalankan Sweep Line: \n▪ Setiap interval [L, R] diubah menjadi dua \"event\": (L, +1) dan (R, -1). \n▪ sort(events, ...): Semua event diurutkan. Aturan pengurutannya standar: \npertama berdasarkan koordinat, lalu jika sama, +1 (masuk) didahulukan dari -\n1 (keluar). \n▪ Loop for(int ev_idx ...): Kode menjalankan algoritma sweep line. currOverlap \nmelacak jumlah interval yang sedang aktif, dan mxOverlap menyimpan nilai \nmaksimum yang pernah tercapai. \n- Logika Final: Validasi & Penalti (actual calculation) \no Setelah mxOverlap (jumlah tumpukan maksimum) ditemukan, ada satu lapisan \nvalidasi lagi. \no Mencari Lokasi Valid: mxOverlap saja tidak cukup. Kita harus memastikan ada \nsetidaknya satu titik di dalam rentang di mana tumpukan maksimum terjadi yang \ntidak terlarang. \no Loop Validasi: Kode ini kembali menelusuri event -event untuk mencari segmen di \nmana currOverlap == mxOverlap. \no Cek isForbidden: Untuk setiap segmen tersebut, ia memeriksa apakah titik awal \nsegmen (event_coord) adalah lokasi yang valid. \no Aturan Penalti: \n▪ Jika ditemukan lokasi yang valid (ok = true), maka jawaban untuk skenario \nini adalah actual = mxOverlap. \n▪ Jika semua lokasi di mana tumpukan maksimum terjadi ternyata terlarang (ok \n= false), kita tidak bisa menempatkan pengamat di sana. Logika di balik \nactual = max(0, mxOverlap - 1) kemungkinan adalah kita harus \n\"mengorbankan\" satu pejalan kaki untuk sedikit m enggeser posisi pengamat \nke tempat yang valid. \nOptimasi (Revisi) \nSetelah saya telaah dan mencoba submit kembali , kita dapat menghapus kode bagian : \n \nTujuan Awal Bagian Kode Tersebut \nTujuan dari bagian kode tersebut a"}
{"text": "ungkinan adalah kita harus \n\"mengorbankan\" satu pejalan kaki untuk sedikit m enggeser posisi pengamat \nke tempat yang valid. \nOptimasi (Revisi) \nSetelah saya telaah dan mencoba submit kembali , kita dapat menghapus kode bagian : \n \nTujuan Awal Bagian Kode Tersebut \nTujuan dari bagian kode tersebut adalah untuk membuat serangkaian kandidat solusi yang \nlebih komprehensif . \nSaya menulis Kode tersebut karena berpikir seperti ini: \"Saya harus memilih kecepatan dan \nsudut berjalan saya untuk menabrak orang sebanyak mungkin. Nilai optimal untuk \nperpindahan horizontal saya ( chosen ) kemungkinan besar adalah salah satu dari beberapa \n'titik kritis' berikut: ” \n- Berjalan dengan kecepatan horizontal maksimum: Ini adalah kasus ekstrem. Mungkin \ndengan bergerak secepat mungkin ke samping, saya bisa 'mengejar' dan menabrak \nlebih banyak orang. Ini diwakili oleh -dMxDisp dan dMxDisp yang sudah ada \n\n- Berjalan lurus ke depan: Ini adalah kasus paling sederhana. Mungkin strategi terbaik \nadalah tidak menyimpang sama sekali dan hanya berjalan lurus. Inilah tujuan dari \nbaris : \n \n- Berjalan sejajar dengan pejalan kaki lain: Jika saya berjalan dengan sudut dan \nkecepatan yang sama persis dengan pejalan kaki lain, jalur kami akan sejajar. Jika \nkami mulai dari posisi x yang berbeda, kami tidak akan pernah bertabrakan. Tapi, jika \nsaya menyesuaikan sudut saya agar sedikit berbeda, saya mungkin bisa memotong \njalur beberapa orang sekaligus. Hipotesisnya adalah, sudut yang optimal mungkin \nsangat dekat dengan sudut pejalan kaki lain. Berjalan dengan perpindahan horizontal \nmdispx[i] yang sama dengan pejalan kaki i adalah cara untuk menguji skenario \n\"berjalan sejajar\" ini. Inilah tujuan dari loop : \n \nSingkatnya, saya bersikap sangat hati -hati untuk menghandle edge case . saya tidak yak"}
{"text": "gat dekat dengan sudut pejalan kaki lain. Berjalan dengan perpindahan horizontal \nmdispx[i] yang sama dengan pejalan kaki i adalah cara untuk menguji skenario \n\"berjalan sejajar\" ini. Inilah tujuan dari loop : \n \nSingkatnya, saya bersikap sangat hati -hati untuk menghandle edge case . saya tidak yakin di \nmana solusi terbaik berada, jadi saya menguji semua kemungkinan yang masuk akal: \nekstrem, nol (lurus), dan meniru setiap pejalan kaki lain. Ini adalah strategi yang aman untuk \nmemastikan tidak ada kasus yang terlewat, tetapi hasilnya adalah waktu eksekusi yang lebih \nlama . \nAlasan Penghapusan kode \nSaat saya mencoba menyelesaikan problem ini, saya menulis kode seperti yang mendapat \ntime 0.04 yang logikanya sudah benar, tetapi saya curiga performanya bisa lebih baik, \nterutama untuk kasus uji yang besar. Saya pun mulai menganalisis di mana letak potensi \nperlambatan dalam kode saya . \nSaya sadar bagian paling lambat dari kode adalah loop yang menguji setiap kandidat \nperpindahan ( dCand ). Jika ada 1000 pejalan kaki, loop itu bisa berjalan 1000 kali, yang \nmembuat total pengerjaan menjadi terlalu lambat . \nSaya berasumsi bahwa untuk masalah memaksimalkan tabrakan seperti ini, jawaban \nterbaiknya kemungkinan besar tidak ditemukan pada kasus \"rata -rata\" (seperti berjalan lurus \natau sejajar orang lain). Sebaliknya, solusi optimal biasanya terjadi saat kita mendo rong \nsistem ke kondisi paling ekstrem . \n\nBerdasarkan asumsi itu, saya memutuskan untuk hanya menguji dua kasus paling ekstrem: \nberjalan dengan kecepatan horizontal maksimum ke kiri ( -dMxDisp ) dan ke kanan \n(+dMxDisp ). Saya pun menghapus kandidat -kandidat \"tanggung\" lainnya dari dCand . \nOptimasi ini berhasil karena ternyata asumsi saya benar untuk semua test case yang ada. \nSolusi optimalnya memang sel"}
{"text": " paling ekstrem: \nberjalan dengan kecepatan horizontal maksimum ke kiri ( -dMxDisp ) dan ke kanan \n(+dMxDisp ). Saya pun menghapus kandidat -kandidat \"tanggung\" lainnya dari dCand . \nOptimasi ini berhasil karena ternyata asumsi saya benar untuk semua test case yang ada. \nSolusi optimalnya memang selalu ditemukan di salah satu dari dua skenario ekstrem tersebut, \nsehingga pengujian lainnya tidak perlu dan hanya membuang waktu . \nKesimpulan \nAlasan Memutuskan Untuk Merubah Kode \nAwalnya, saya mendekati masalah ini secara analitis menggunakan lazy segment tree pada Kode 1. \nPendekatan ini kuat secara matematis untuk menyelesaikan masalah geometri 2D secara umum. \nPendekatan analitis pertama (Kode 1), meskipun kuat secara matematis, memiliki overhead komputasi \nyang lumayan besar pada setiap operasinya. Cost dari pembaruan dan kueri pada segment tree yang \nkompleks menjadi penghalang utama. Keputusan untuk beralih did asari oleh prinsip efisiensi praktis: \nkami mengorbankan kemampuan untuk menyelesaikan masalah secara kontinu demi sebuah model \nyang jauh lebih cepat untuk kasus -kasus yang paling mungkin menjadi solusi optimal. \nSaya beralih ke Kode 2 setelah menemukan ide kunci untuk menyederhanakan masalah yaitu daripada \nmencari solusi di ruang kemungkinan yang tak terbatas, saya melakukan diskritisasi. Yaitu, saya \nhanya menguji beberapa kandidat lintasan yang paling potensial (misalnya lurus, sudut maksimal, \natau meniru lintasan lain). Hal ini mengubah masalah ya ng rumit menjadi beberapa sub -masalah yang \njauh lebih sederhana dan efisien . \nApa yang membuat kode kedua lebih efisien \nMeskipun secara teori kompleksitas waktu keduanya bisa jadi sama (didominasi oleh sorting, \nO(NlogN)), efisiensi praktis Kode 2 jauh lebih unggul karena constant factor -nya yang lebih k"}
{"text": "enjadi beberapa sub -masalah yang \njauh lebih sederhana dan efisien . \nApa yang membuat kode kedua lebih efisien \nMeskipun secara teori kompleksitas waktu keduanya bisa jadi sama (didominasi oleh sorting, \nO(NlogN)), efisiensi praktis Kode 2 jauh lebih unggul karena constant factor -nya yang lebih kecil. \n• Kode 1: Menggunakan lazy segment tree yang setiap operasinya (update dan query rentang) \nmemiliki overhead komputasi yang besar dan implementasi yang lebih berat. \n• Kode 2: Menggantinya dengan algoritma sweep -line standar yang pada dasarnya hanya \nmelakukan iterasi linear setelah sorting. Operasi dasarnya jauh lebih ringan. Dengan hanya \nmenguji beberapa kandidat lintasan, kita menjalankan algoritma yang sangat cepat in i \nbeberapa kali, yang secara total jauh lebih efisien daripada menjalankan satu algoritma berat \nseperti di Kode 1. \nAtau untuk membedakannya kita dapat mengidentifikasi perbedaan krusialnya: \n- Lazy Segment Tree: Bekerja pada struktur data yang dirancang untuk menjawab query secara \nonline. \n- Sweep Line: Adalah sebuah algoritma yang bekerja secara offline. \nParadigma: Online vs. Offline \n- Lazy Segment Tree (Online): \no Algoritma online harus memproses input dan menjawab query satu per satu, tanpa \nmengetahui input atau query yang akan datang di masa depan. \no Segment Tree membangun sebuah struktur data yang siap sedia. Setiap saat, kita bisa \nmemberinya perintah update (tambahkan X pada rentang [L,R]) atau query (apa nilai \nmaksimum pada rentang [L,R]?). Struktur tree harus selalu dalam keadaan valid \nuntuk menjawab query saat itu juga. \no Inilah harga yang harus dibayar untuk fleksibilitas online. Perjalanan O(logN) \nmenuruni pohon adalah cara struktur data ini menggabungkan informasi untuk \nmemberikan jawaban yang benar berdasarkan semua updat"}
{"text": "?). Struktur tree harus selalu dalam keadaan valid \nuntuk menjawab query saat itu juga. \no Inilah harga yang harus dibayar untuk fleksibilitas online. Perjalanan O(logN) \nmenuruni pohon adalah cara struktur data ini menggabungkan informasi untuk \nmemberikan jawaban yang benar berdasarkan semua update yang telah terjadi hingga \ndetik itu. \n- Sweep Line (Offline): \no Algoritma offline dapat (dan harus) membaca semua input sekaligus sebelum mulai \nbekerja. Ia melihat \"gambaran besar\" dari awal. \no Sweep Line tidak membangun struktur data serbaguna. Ia mengubah masalah interval \nmenjadi masalah event point. Ia hanya peduli pada titik awal dan akhir interval (\"titik \nkritis\"). Dengan mengurutkan semua titik kritis ini dan memprosesnya secara \nberurutan, ia dapat membangun solusi langkah demi Langkah. \no Karena ia sudah tahu semua interval dari awal, ia bisa mengambil jalan pintas. Ia \ntidak perlu siap untuk query acak di tengah jalan. Ia hanya perlu menghitung hasil \nakhir setelah semua event diproses. \nKenapa Menggunakan \"Displacement Candidates\"? Menyederhanakan Ruang \nPencarian \nKarena kami berhipotesis bahwa solusi optimal untuk memaksimalkan tumpukan interval \nkemungkinan besar akan terjadi pada salah satu titik kritis ini. Daripada mencari di ruang solusi yang \ntak terbatas (setiap kemungkinan sudut), kami secara cerdas mengerucu tkan masalah ke beberapa \nskenario yang paling logis. Ini adalah keputusan sadar untuk tidak menyelesaikan masalah secara \nbrute -force, melainkan menggunakan intuisi masalah untuk memangkas ruang pencarian secara \ndrastis \nMekanisme Tabrakan Pada Kode Pertama dan Kode Kedua \nKeduanya setuju bahwa tabrakan hanya bisa terjadi jika waktu menyeberang (ti) sama. Perbedaannya \nada pada cara mereka memodelkan kondisi tabrakan tersebut. \n• Kode 1 (Mo"}
{"text": "menggunakan intuisi masalah untuk memangkas ruang pencarian secara \ndrastis \nMekanisme Tabrakan Pada Kode Pertama dan Kode Kedua \nKeduanya setuju bahwa tabrakan hanya bisa terjadi jika waktu menyeberang (ti) sama. Perbedaannya \nada pada cara mereka memodelkan kondisi tabrakan tersebut. \n• Kode 1 (Model Geometris): Memodelkan setiap lintasan sebagai garis. Tabrakan dianggap \nsebagai perpotongan antara garis lintasan saya dan garis lintasan pejalan kaki lain. Segment \ntree digunakan sebagai alat canggih untuk secara efisien menghitung berapa ba nyak garis \nyang bisa saya potong dengan memilih lintasan saya secara optimal. \n• Kode 2 (Model Interval): Menerjemahkan kondisi tabrakan menjadi interval di garis start. \nUntuk setiap lintasan yang saya pilih, dan untuk setiap pejalan kaki lain, ada sebuah rentang \n(interval) posisi start bagi saya yang akan menyebabkan tabrakan. Mekanis menya adalah: \n1. Pilih sebuah kandidat lintasan. \n2. Hitung \"interval tabrakan\" untuk semua pejalan kaki. \n3. Gunakan sweep -line untuk mencari titik di garis start yang paling banyak ditutupi \noleh interval -interval tersebut. Titik itulah posisi start terbaik saya . \nPerbedaan Sweep Line Kode 1 dan Kode 2 \nPerbedaan mendasar antara sweep line pada kedua kode tersebut terletak pada kompleksitas masalah \nyang diselesaikan dan struktur data yang digunakan untuk mengelola \"state\" saat proses sweep \nberlangsung. \nKode 2: Pure Sweep Line \nPada kode ini, sweep line digunakan untuk masalah 1D, seperti mencari tumpukan interval \nmaksimum. \n- State: Dikelola oleh sebuah counter integer sederhana. \n- Tujuan: Hanya untuk menghitung berapa banyak interval yang aktif pada satu titik (+1 saat \nmulai, -1 saat selesai). \nKode 1: Sweep Line dengan Segment Tree. \nPada kode ini, sweep line digunakan untuk mereduks"}
{"text": "i tumpukan interval \nmaksimum. \n- State: Dikelola oleh sebuah counter integer sederhana. \n- Tujuan: Hanya untuk menghitung berapa banyak interval yang aktif pada satu titik (+1 saat \nmulai, -1 saat selesai). \nKode 1: Sweep Line dengan Segment Tree. \nPada kode ini, sweep line digunakan untuk mereduksi masalah 2D menjadi 1D, contohnya seperti \nmenghitung total luas gabungan dari beberapa persegi panjang. \n- State: Dikelola oleh struktur data yang lebih kompleks, yaitu Segment Tree. \n- Tujuan: Bukan hanya menghitung jumlah interval aktif, tetapi mengelola sebuah kumpulan \ninterval pada sumbu lainnya. Segment Tree bertugas mencari informasi agregat dari \nkumpulan tersebut, seperti total panjang gabungan dari semua interval yang sedang aktif . \nSingkatnya: Keduanya sama -sama melakikan \"sweep\" dari satu titik ke titik lain, tetapi Pure Sweep \nLine hanya menggunakan counter biasa, sementara Sweep Line pada kode pertama memerlukan \nSegment Tree untuk mencatat dan mengkalkulasi keadaan yang jauh lebih rumit di setiap \nperhentiannya. \nMengapa Awalnya Menggunakan Lazy Segment Tree Lalu Tidak \nIni adalah perbedaan fundamental dari kedua approach saya : \n• Kode 1 memerlukan lazy segment tree karena mencoba menyelesaikan masalah secara \nanalitis dan kontinu. Kode perlu menjawab pertanyaan kompleks seperti: \"Untuk rentang \nposisi awal x dari A sampai B, berapakah jumlah tabrakan maksimal yang bisa saya capai \ndengan memilih posisi akhir y di mana saja dalam rentang x +/ - add?\". Pertanyaan range \nquery yang dinamis seperti in i adalah tugas klasik untuk segment tree. \n• Kode 2 tidak lagi memerlukan segment tree karena masalahnya sudah disederhanakan secara \ndrastis. Dengan melakukan diskritisasi (memilih satu kandidat lintasan), pertanyaan kompleks \ntadi berubah menjadi masalah tumpa"}
{"text": " range \nquery yang dinamis seperti in i adalah tugas klasik untuk segment tree. \n• Kode 2 tidak lagi memerlukan segment tree karena masalahnya sudah disederhanakan secara \ndrastis. Dengan melakukan diskritisasi (memilih satu kandidat lintasan), pertanyaan kompleks \ntadi berubah menjadi masalah tumpang tindih interval statis. Masalah ini da pat diselesaikan \ndengan sangat efisien hanya dengan sorting dan satu kali sapuan (sweep -line), sehingga \nstruktur data sekuat segment tree menjadi tidak perlu dan berlebihan (overkill) . \n \n \n \nDaftar Pustaka: \n1. Wenku Baidu. (n.d.). Pembahasan Zebra . Diakses dari \nhttps://wenku.baidu.com/view/d1a80b3743323968011c9260?pcf=2&bfetype=new&wkts=17\n46524225396&needWelcomeRecommand=1&wkts=1746543158932 \n2. GeeksforGeeks. (n.d.). Coordinate Compression. Diakses dari \nhttps://www.geeksforgeeks.org/coordinate -compression/ \n3. GeeksforGeeks. (n.d.). Segment Tree Data Structure . Diakses dari \nhttps://www.geeksforgeeks.org/segment -tree-data-structure/ \n4. cp-algorithms.com. (n.d.). Segment Tree . Diakses dari https://cp -\nalgorithms.com/data_structures/segment_tree.html \n5. GeeksforGeeks. (n.d.). Lazy Propagation in Segment Tree . Diakses dari \nhttps://www.geeksforgeeks.org/lazy -propagation -in-segment -tree/ \n6. USACO Guide. (n.d.). Sweep Line Algorithm . Diakses dari https://usaco.guide/plat/sweep -\nline?lang=cpp \n7. GeeksforGeeks. (n.d.). Given a Set of Line Segments, Find if Any Two Segments Intersect . \nDiakses dari https://www.geeksforgeeks.org/given -a-set-of-line-segments -find-if-any-two-\nsegments -intersect/ \n8. GeeksforGeeks. (n.d.). Two Pointers Technique . Diakses dari \nhttps://www.geeksforgeeks.org/two -pointers -technique/ \n9. USACO Guide. (n.d.). Two Pointers . Diakses dari https://usaco.guide/silver/two -\npointers?lang=cp"}
{"text": "ks.org/given -a-set-of-line-segments -find-if-any-two-\nsegments -intersect/ \n8. GeeksforGeeks. (n.d.). Two Pointers Technique . Diakses dari \nhttps://www.geeksforgeeks.org/two -pointers -technique/ \n9. USACO Guide. (n.d.). Two Pointers . Diakses dari https://usaco.guide/silver/two -\npointers?lang=cpp \n10. Zenius. (n.d.). Pengertian dan Rumus Gerak Lurus Beraturan (GLB) . Diakses dari \nhttps://www.zenius.net/blog/pengertian -rumus -glb-adalah/ \n11. Halim, S. (2015). Competitive Programming 4 . Bab 7, Sub Bab 7.2: Computational \nGeometry."}
